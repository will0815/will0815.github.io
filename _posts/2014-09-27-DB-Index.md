---
layout: post
title: DB Index
category: DB
date: 2014-09-27
duoshuo： true
share: true
---
  理解索引结构     
 
  实际上，可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别： 
     
  其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查"安"字，就会很自然地翻开字典的前几页，因为"安"的拼音是"an"，而按照拼音排序汉字的字典是以英文字母"a"开头并以"z"结尾的，那么"安"字就自然地排在字典的前部。如果您翻完了所有以"a"开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查"张"字，那您也会将您的字典翻到最后部分，因为"张"的拼音是"zhang"。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。  
    
  我们把这种正文内容本身就是一种按照一定规则排列的目录称为"聚集索引"。      

  如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据"偏旁部首"查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合"部首目录"和"检字表"而查到的字的排序并不是真正的正文的排序方法，比如您查"张"字，我们可以看到在查部首之后的检字表中"张"的页码是672页，检字表中"张"的上面是"驰"字，但页码却是63页，"张"的下面是"弩"字，页面是390页。很显然，这些字并不是真正的分别位于"张"字的上下方，现在您看到的连续的"驰、张、弩"三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。 
     
  我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"。 

何时使用聚集索引或非聚集索引      
下面的表总结了何时使用聚集索引或非聚集索引（很重要）。   
     
		动作描述        使用聚集索引 使用非聚集索引     
		列经常被分组排序      应        应     
		返回某范围内的数据          应      不应        
		一个或极少不同值           不应     不应     
		小数目的不同值                应     不应     
		大数目的不同值              不应    应     
		频繁更新的列                 不应   应     
		外键列                  应 应     
		主键列               应   应     
		频繁修改索引列       不应      应        

几种常见的MySQL索引类型。

 1. 普通型索引
     这是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建： 

   1. 创建索引，例如CREATE INDEX 索引的名字 ON tablename (列名1，列名2,...); 
   2. 修改表，例如ALTER TABLE tablename ADD INDEX 索引的名字 (列名1，列名2,...); 
   3. 创建表的时候指定索引，例如CREATE TABLE tablename ( [...], INDEX 索引的名字 (列名1，列名
      2,...) );
 2. 唯一索引
   这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。唯一性索引可以用以下几种方式创建： 

   1. 创建索引，例如CREATE UNIQUE INDEX 索引的名字 ON tablename (列的列表); 
   2. 修改表，例如ALTER TABLE tablename ADD UNIQUE 索引的名字 (列的列表); 
   3. 创建表的时候指定索引，例如CREATE TABLE tablename ( [...], UNIQUE 索引的名字 (列的列
     表) );

3. 主键

    主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”。如果你曾经用过AUTO_INCREMENT类型的列，你可能已经熟悉主键之类的概念了。主键一般在创建表的时候指定，例如“CREATE TABLE tablename ( [...], PRIMARY KEY (列的列表) ); ”。但是，我们也可以通过修改表的方式加入主键，例如“ALTER TABLE tablename ADD PRIMARY KEY (列的列表); ”。每个表只能有一个主键。 （主键相当于聚合索引，是查找最快的索引）
4. 单列索引和多列索引
 
    索引可以是单列索引，也可以是多列索引。
    1. 单列索引就是常用的一个列字段的索引，常见的索引。
    2. 多列索引就是含有多个列字段的索引
    
        	 alter table student add index sy(name,age，score);
        	 索引sy就为多列索引，多列索引在以下几中情况下才能有效：
        	 select * from student where name='jia' and age>='12' //where条件中含有索引的首列字段和
       		   第二个字段
        	 select * from student where name='jia' //where条件中只含有首列字段
        	 select * from student where name='jia' and score<60//where条件中含有首列字段和第三个字
       		  段
       		 总结：多列索引只有在where条件中含有索引中的首列字段时才有效
5. 选择索引列

     应该怎样选择索引列，首先要看查询条件，一般将查询条件中的列作为索引

**联合索引使用结论:**

1. 查询条件中出现联合索引第一列,或者全部,则能利用联合索引.
2. 条件列中只要条件相连在一起,以本文例子来说就是:
last_name=’1′ and first_name=’1′与first_name=’1′ and last_name=’1′
,无论前后,都会利用上联合索引.
3. 查询条件中没有出现联合索引的第一列,而出现联合索引的第二列,或者第三列,都不会利用联合索引查询.

**单一列索引的应用结论:**

   只要条件列中出现索引列,无论在什么位置,都能利用索引查询.

**两者的共同点:**

1. 要想利用索引,都要符合SARG标准.
2. 都是为了提高查询速度.
3. 都需要额外的系统开销,磁盘空间.

补充说明: stmtText信息来产生,在查询语句前面加上:SET STATISTICS PROFILE on.可以通过运行它,来观察你的查询是否合理,这样才能真正做到优化.

**主旨:讨论什么情况下能利用上索引.**

索引:创建索引可以根据查询业务的不同分为两种:单一列的索引,联合索引. 顾名思义,单一列索引就是指在表的某一列上创建索引,联合索引是在多个列上联合创建索引.

优缺点比较:

1. 索引所占用空间:单一列索引相对要小.
2. 索引创建时间:单一列索引相对短.
3. 索引对insert,update,delete的影响程序:单一列索引要相对低.
4. 在多条件查询时,联合索引效率要高.

索引的使用范围:单一列索引可以出现在where 条件中的任何位置,而联合索引需要按一定的顺序来写. 
   
  
