<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="description" content="Will go, Just do it.">
  <meta name="author" content="Will.Quan">
  <meta name="keywords" content="Will go, Just do it., willgo, 最好的从未错过, Will.Quan">
  <title>Will go, Just do it.</title>
  <link rel="canonical" href="index.html">
  <link rel="icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/res/css/public.css">
  <link rel="stylesheet" href="/res/css/light.css">
  <script src="/res/js/light.js"></script>
  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fda48b6233123178f300913a0e707883e' type='text/javascript'%3E%3C/script%3E"));
</script>

</head>
<body>
  <div id="blog">
    <div class="sidebar">
  <div class="profilepic">
    <a href="/"><img src="/res/img/icon.png" alt="logo"></img></a>
  </div>
  <h1 class="title"><a href="/">willgo</a></h1>
  <h2 class="sub-title">最好的从未错过</h2>
  <nav id="nav">
    <ul>
    
      <li><a href="/page/timing.html"><i class="fa fa-clock-o"></i>&nbsp;资料时间</a></li>
    
      <li><a href="/page/category.html"><i class="fa fa-tags"></i>&nbsp;文章分类</a></li>
    
      <li><a href="/page/read.html"><i class="fa fa-book"></i>&nbsp;逗绊读书</a></li>
    
      <li><a href="/page/life.html"><i class="fa fa-eyedropper"></i>&nbsp;生活记录</a></li>
    
      <li><a href="/page/about.html"><i class="fa fa-paper-plane-o"></i>&nbsp;假装关于</a></li>
    
    </ul>
  </nav>  
  <nav id="sub-nav">
    <a class="weibo " href="http://weibo.com/u/2369015654" title="新浪微博" target="_blank"><i class="fa fa-weibo"></i></a>
    <a class="github" href="https://github.com/will0815/" title="GitHub" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    <a class="rss" href="/page/feed.xml" title="RSS订阅" target="_blank"><i class="fa fa-rss"></i></a>
  </nav>
  <div id="license">
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" title="本站所有作品采用：&#10;知识共享《署名 非商业性使用 相同方式共享 3.0》&#10;进行许可" >
    <img alt="License" height="31" width="88" src="/res/img/license.png" /></a>
  </div>
</div>

    <div class="main">
        <div style="font-family: segoepr;font-size: 40px;
              margin-top:-5px; color:#fff;">
            <script type="text/javascript" 
            src="http://open.iciba.com/ds_open.php?id=11519&name=willgo&auth=BE45CDE6481CC46336529A1B407855B1" charset="utf-8">
            </script>
        </div>
    
<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/05/16/HBase-config-optimize.html">HBase config optimize</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年05月16日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#hadoop">hadoop</a>
      </p>
    </header>
    <div class="post-main">
      

      <div class="readall"><a href="/blog/2015/05/16/HBase-config-optimize.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/05/16/DB-yanjin.html">DB演进理解</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年05月16日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#db">db</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="db">DB演进理解</h2>

<ol>
  <li>
    <p>RDBMS<br />
这是最熟悉的数据存储方式，一般情况下数据存储在一台机器上，这种形式方便提供完善ACID特性和丰富查询模型。这就是传统的关系型数据库的基础模式，但是面对现如今越来越大的数据量，这种模式的扩展变得难以满足。实践证明通过增加节点这种简单廉价的扩展方式是可行的。RDBMS的横向扩展主要有主从复制（Master-slave）、分表、分区等。 <br />
横向扩展RDBMS – Master/Slave <br />
利用数据库的复制或镜像功能，同时在多台数据库上保存相同的数据，从而将读操作和写操作分开，写操作集中在一台主数据库上，读操作集中在多台从数据库上。<br />
问题：<br />
读写同步需要一定的时间，导致关键的读取有出错风险；<br />
主节点将数据复制到从节点，数据量很大是可能造成问题，  </p>

    <p>横向扩展RDBMS - Sharding <br />
 在满足ACID特性的数据库中进行扩展是非常难的。基于这个原因，对数据进行扩展，这个数据库本身就必须拥有简单的模型，将数据分割为N片，然后在单独的片中执行查询。数据分割的单元被称为“shard”。将N片数据分配个M个DBMS进行操作。DBMS并不会去管理数据片，程序开发负责数据片的处理。
 不同的分片方法有：<br />
 - 垂直分区（Vertical Partitioning）：将不需要进行联合查询的数据表分散到不同的数据库服务器上。<br />
 - 水平分区(sharding) 将同一个表的记录拆分到不同的表甚至是服务器上，这往往需要一个稳定的算法来保证读取时能正确从不同的服务器上取得数据。如Range-Based Partitioning, Key or Hash-Based partitioning等。<br />
 优点与不足<br />
 - 对读取和写入都有很好的扩展<br />
 - 不透明，程序需要识别分区 <br />
 - 不再有跨分区的关系/joins <br />
 - 参照完整性损失  </p>

    <p>其他RDBMS扩展方法 <br />
 Multi-Master replication：所有成员都响应客户端数据查询。多主复制系统负责将任意成员做出的数据更新传播给组内其他成员，并解决不同成员间并发修改可能带来的冲突。<br />
 INSERT only, not UPDATES/DELETES：数据进行版本化处理。<br />
 No JOINs, thereby reducing query time：Join的开销很大,而且频繁访问会使开销随着时间逐渐增加。<br />
 非规范化（Denormalization）可以降低数据仓库的复杂性，以提高效率和改善性能。<br />
 In-memory databases：磁盘数据库解决的是大容量存储和数据分析问题，内存数据库解决的是实时处理和高并发问题。主流常规的RDBMS更多的是磁盘密集型，而不是内存密集型。  </p>

    <p>ACID Transactions<br />
 一个完善的数据库系统都是希望支持“ACID transactions,”其包括:<br />
 Atomic : Either the whole process is done or none is.（原子性）<br />
 Consistent : Database constraints are preserved.（一致性）<br />
 Isolated : It appears to the user as if only one process executes at a time.（隔离性）<br />
 Durable : Effects of a process do not get lost if the system crashes.（持久性）  </p>
  </li>
  <li>
    <p>NoSQL  </p>
  </li>
</ol>

<p>NoSQL现在被理解为 Not Only SQL 的缩写，是对非关系型的数据库管理系统的统称
NoSQL 与 RDBMS 不同点，<br />
-不使用SQL作为查询语言。<br />
-不需要固定的表模式(table schema)。<br />
- 放宽一个或多个 ACID 属性（CAP定理）  </p>

<p>补充：CAP理论<br />
CAP理论是数据系统设计的基本理论，目前几乎所有的数据系统的设计都遵循了这个理论。CAP理论指出，分布式系统只能满足以下三项中的两项而不可能满足全部三项，<br />
一致性（Consistency)（所有节点在同一时间具有相同的数据）<br />
可用性（Availability）（保证每个请求不管成功或者失败都有响应）<br />
分区容忍性（Partition tolerance）（系统中任意信息的丢失或失败不会影响系统的继续运作） </p>

<p>一致性有两种类型：<br />
- strong consistency – ACID(Atomicity Consistency Isolation Durability)：对于关系型数据库，要求更新过的数据能被后续所有的访问都看到，这是强一致性。<br />
- weak consistency – BASE(Basically Available Soft-state Eventual consistency )
– Basically Available - system seems to work all the time (基本可用)<br />
– Soft State - it doesn’t have to be consistent all the time （不要求所有时间都一致）<br />
– Eventually Consistent - becomes consistent at some later time （最终一致性）  </p>

<p>对于分布式数据系统(scale out)，分区容忍性是基本要求，否则就失去了价值。因此只能在一致性和可用性上做取舍，如何处理这种取舍正是目前NoSQL数据库的核心焦点。牺牲一致性而换取高可用性。当然，牺牲一致性，只是不再要求关系数据库中的强一致性，而是只要系统能达到最终一致性即可。通常是通过数据的多份异步复制来实现系统的高可用和数据的最终一致性的。  </p>

<p>NoSQL 的两种主要实现方式<br />
1.Key/Value<br />
Amazon S3 (Dynamo)<br />
Voldemort <br />
Scalaris <br />
Memcached (in-memory key/value store)<br />
Redis <br />
2. 弱模式型（column-based, document-based or graph-based.）<br />
Cassandra (column-based)<br />
CouchDB (document-based)<br />
MongoDB(document-based) <br />
Neo4J (graph-based)<br />
HBase (column-based)   </p>

<p>K/V模式<br />
优点:<br />
very fast<br />
very scalable<br />
simple model<br />
able to distribute horizontally<br />
劣势: <br />
 many data structures (objects) can’t be easily modeled as key value pairs （需要多余转换）<br />
Schema-Less 模式<br />
优点<br />
Schema-less data model is richer than key/value pairs
eventual consistency<br />
many are distributed<br />
still provide excellent performance and scalability<br />
劣势<br />
typically no ACID transactions or joins  </p>

<ol>
  <li>HBase  </li>
</ol>

<p>HBase is an open-source, distributed, column-oriented database built on top of HDFS (or KFS) based on BigTable! <br />
按照CAP理论，HBase属于C+P类型的系统。HBase是强一致性的（仅支持单行事务）。每一行由单个区域服务器（region server）host，行锁（row locks）和多版本并发控制(multiversion concurrency control)的组合被用来保证行的一致性。<br />
查找:<br />
快速定位使用row key + column family + column + timestamp.<br />
按范围查找：start row key – end row key.<br />
全表扫描<br />
交互方式<br />
- Java, REST, or Thrift APIs.<br />
- Scripting via JRuby.  </p>

<p>HBase 一些特性  </p>

<pre><code>- No real indexes（row key 即数据的索引）  
- Automatic partitioning（region自动split）  
- Scale linearly and automatically with new nodes（扩展容易 节点添加方便）  
- Commodity hardware（廉价硬件）  
- Fault tolerance(较强的容错性)  
- Batch processing(批处理能力优秀)  
</code></pre>

<ol>
  <li>
    <p>Hive    </p>

    <ul>
      <li>Provide higher-level language (HQL, like SQL) to facilitate large-data processing</li>
      <li>Higher-level language “compiles down” to Hadoop Map/Reduce jobs</li>
    </ul>
  </li>
  <li>
    <p>Hive + HBase  </p>

    <p>Reasons to use Hive on HBase:<br />
 A lot of data sitting in HBase due to its usage in a real-time environment, but never used for analysis<br />
 Give access to data in HBase usually only queried through MapReduce to people that don’t code (business analysts)<br />
 When needing a more flexible storage solution, so that rows can be updated live by either a Hive job or an application and can be seen immediately to the other</p>
  </li>
</ol>


      <div class="readall"><a href="/blog/2015/05/16/DB-yanjin.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/05/16/CDH-install-question.html">CDH 安装问题</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年05月16日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#hadoop">hadoop</a>
      </p>
    </header>
    <div class="post-main">
      <p><em>CDH5安装参照：http://www.tuicool.com/articles/ENjmeaY</em><br />
Q1:安装过程中提示找不到MySQL 驱动jar包<br />
	：在/usr/shar/java 中添加mysql-connector-java-5.1.30-bin.jar<br />
Q2：安装hive提示找不到MySQL驱动jar包<br />
：在/opt/cloudera/parcels/CDH-5.1.3-1.cdh5.1.3.p0.12/lib/hive/lib/ 中添加 mysql-connector-java-5.1.30-bin.jar<br />
Q3: cloudera-server 或cloudera-agent  status 提示服务已经停止，pid仍然存在<br />
	：查看对应的log 可能是端口占用或是数据库连接问题<br />
Q4:MR2和HDFS安装好后 web ui无法访问，查看对应端口已经处于listen状态，<br />
	：分别在对应的配置中的端口和地址选项中将“将 ResourceManager 绑定到通配符地址”项， 勾选上<br />
没有这个选项的可以在高级设置中在XML文件中添加<br />
Q5：jdk版本不对应<br />
	： CDH默认获取的jdk 位于：/usr/java   可将需要的jdk 拷贝到这个目录中。  </p>

<p>Q6  sqoop导入数据时：User does not belong to hive<br />
	I had same issue with permissions -&gt; chgrp: changing ownership of ‘/user/hive/warehouse/test/_log24310.txt’: User does not belong to hive.
1.Added the existing user named cloudera to existing group named hive with command: usermod -a -G hive cloudera 
2.Restarted the system 
3.Used Load Command and after that did a select * from table_name -&gt; No data was getting displayed. 
4.Executed select count(*) from table_name and a MapReduce job got started. 
5.Executed select * from table and now results was returned correctly. 
6.Opened a impala shell using impala-shell command. 
7.Executed a select * from table_name and no results was getting returned. 
8.Executed command invalidate metadata in the impala-shell 
9.Executed command refresh table_name 
10.Executed command show tables 
11.Executed command select * from table_name and now results are getting displayed both in the impala-shell and hive shell. 
  可以不必理会</p>

<p>Q6：spark 安装不上<br />
	未解决，网上有对应bug</p>

<p>整个安装过程中遇到各种问题，主要解决得途径还是查看对应的log文件对应解决：<br />
/var/log/hadoop*<br />
/var/log/cloudera*<br />
/opt/cm-5.1.3/log  </p>

<h6 id="about">===========================about==================================================================================================================================</h6>
<p>问题导读  </p>

<pre><code>1.CM的安装目录在什么位置？  
2.hadoop配置文件在什么位置？  
3.Cloudera manager运行所需要的信息存在什么位置？  
4.CM结构和功能是什么？  
1. 相关目录  
/var/log/cloudera-scm-installer : 安装日志目录。  
/var/log/* : 相关日志文件（相关服务的及CM的）。  
/usr/share/cmf/ : 程序安装目录。  
/usr/lib64/cmf/ : Agent程序代码。  
/var/lib/cloudera-scm-server-db/data : 内嵌数据库目录。  
/usr/bin/postgres : 内嵌数据库程序。  
/etc/cloudera-scm-agent/ : agent的配置目录。  
/etc/cloudera-scm-server/ : server的配置目录。  
/opt/cloudera/parcels/ : Hadoop相关服务安装目录。  
/opt/cloudera/parcel-repo/ : 下载的服务软件包数据，数据格式为parcels。  
/opt/cloudera/parcel-cache/ : 下载的服务软件包缓存数据。  
/etc/hadoop/* : 客户端配置文件目录。  
</code></pre>

<ol>
  <li>配置    </li>
</ol>

<p>Hadoop配置文件<br />
配置文件放置于/var/run/cloudera-scm-agent/process/目录下。如：/var/run/cloudera-scm-agent/process/193-hdfs-NAMENODE/core-site.xml。这些配置文件是通过Cloudera Manager启动相应服务（如HDFS）时生成的，内容从数据库中获得（即通过界面配置的参数）。<br />
在CM界面上更改配置是不会立即反映到配置文件中，这些信息会存储于数据库中，等下次重启服务时才会生成配置文件。且每次启动时都会产生新的配置文件。<br />
CM Server主要数据库为scm基中放置配置的数据表为configs。里面包含了服务的配置信息，每一次配置的更改会把当前页面的所有配置内容添加到数据库中，以此保存配置修改历史。<br />
scm数据库被配置成只能从localhost访问，如果需要从外部连接此数据库，修改vim /var/lib/cloudera-scm-server-db/data/pg_hba.conf文件,之后重启数据库。运行数据库的用户为cloudera-scm。  </p>

<p>查看配置内容<br />
1.直接查询scm数据库的configs数据表的内容。  <br />
2.访问REST API： http://hostname:7180/api/v4/cm/deployment，返回JSON格式部署配置信息。  </p>

<p>配置生成方式<br />
CM为每个服务进程生成独立的配置目录（文件）。所有配置统一在服务端查询数据库生成（因为scm数据库只能在localhost下访问）生成配置文件，再由agent通过网络下载包含配置文件的zip包到本地解压到指定的目录。  </p>

<p>配置修改<br />
CM对于需要修改的配置预先定义，对于没有预先定义的配置,则通过在高级配置项中使用xml配置片段的方式进行配置。而对于/etc/hadoop/下的配置文件是客户端的配置，可以在CM通过部署客户端生成客户端配置。  </p>

<ol>
  <li>数据库<br />
Cloudera manager主要的数据库为scm,存储Cloudera manager运行所需要的信息：配置，主机，用户等。  </li>
  <li>CM结构 </li>
</ol>

<p>CM分为Server与Agent两部分及数据库（自带更改过的嵌入Postgresql）。它主要做三件事件：</p>

<pre><code>1.管理监控集群主机。
2.统一管理配置。
3.管理维护Hadoop平台系统。
实现采用C/S结构，Agent为客户端负责执行服务端发来的命令，执行方式一般为使用python调用相应的服务shell脚本。Server端为Java REST服务，提供REST API，Web管理端通过REST API调用Server端功能，Web界面使用富客户端技术（Knockout）。
1.Server端主体使用Java实现。
2.Agent端主体使用Python, 服务的启动通过调用相应的shell脚本进行启动，如果启动失败会重复4次调用启动脚本。
3.Agent与Server保持心跳，使用Thrift RPC框架。
</code></pre>

<ol>
  <li>升级  </li>
</ol>

<p>在CM中可以通过界面向导升级相关服务。升级过程为三步：</p>

<pre><code>1.下载服务软件包。
2.把所下载的服务软件包分发到集群中受管的机器上。
3.安装服务软件包，使用软链接的方式把服务程序目录链接到新安装的软件包目录上。
</code></pre>

<ol>
  <li>卸载  </li>
</ol>

<p>sudo /usr/share/cmf/uninstall-scm-express.sh, 然后删除/var/lib/cloudera-scm-server-db/目录，不然下次安装可能不成功。</p>

<ol>
  <li>
    <p>开启postgresql远程访问  </p>

    <p>CM内嵌数据库被配置成只能从localhost访问，如果需要从外部查看数据，数据修改vim /var/lib/cloudera-scm-server-db/data/pg_hba.conf文件,之后重启数据库。运行数据库的用户为cloudera-scm。</p>
  </li>
</ol>

      <div class="readall"><a href="/blog/2015/05/16/CDH-install-question.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point9.html">Linux学习笔记9-AWK</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux9-awk">Linux学习笔记9-AWK</h2>
<p>AWK是所有shell过滤工具中最难掌握的，不知道为什么，也许是其复杂的语法或含义不明确的错误提示信息。在学习awk语言过程中，就会慢慢掌握诸如Bailing out 和awk:cmd.Line:等错误信息。可以说awk是一种自解释的编程语言，之所以要在shell中使用awk是因为awk本身是学习的好例子，但结合awk与其他工具诸如grep和sed，将会使shell编程更加
容易。<br />
调用：<br />
有三种方式调用awk，第一种是命令行方式，如：<br />
awk [-F field-separator] ‘awk命令’ input-file(s)<br />
[-F域分隔符]是可选的，因为awk使用空格作为缺省的域分隔符，因此如果
要浏览域间有空格的文本，不必指定这个选项，但如果要浏览诸如passwd文件，此文件各域以冒号作为分隔符，则必须指明- F选项<br />
awk -F:’awk命令’ input-file<br />
第二种方法是将所有awk命令插入一个文件，并使awk程序可执行，然后用awk命令解释器作为脚本的首行，以便通过键入脚本名称来调用它<br />
awk -f awk-script-file input-files<br />
第三种方式是将所有的awk命令插入一个单独文件. -f选项指明在文件awk_scriptfile中的awk脚本，inputfile(s)是使用awk进行浏览的文件
名。  </p>

<p>awk脚本<br />
在命令中调用awk时，awk脚本由各种操作和模式组成。<br />
如果设置了-F选项，则awk每次读一条记录或一行，并使用指定的分隔符分隔指定域，但如果未设置-F选项，awk假定空格为域分隔符，并保持这个设置直到发现一新行。当新行出现时，awk命令获悉已读完整条记录，然后在下一个记录启动读命令，这个读进程将持续到文件尾或文件不再存在。</p>


      <div class="readall"><a href="/blog/2015/02/01/Linux-point9.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point8.html">Linux学习笔记8-grep 家族</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux8-grep-">Linux学习笔记8-grep 家族</h2>
<p>grep（全局正则表达式版本）允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行。grep支持基本正则表达式，也支持其扩展集   <br />
grep一般格式为：<br />
grep [选项]基本正则表达式[文件]<br />
这里基本正则表达式可为字符串。  </p>

<p>在grep命令中输入字符串参数时，最好将其用双引号括起来。例如：“mystring”。这样做有两个原因，
一是以防被误解为shell命令，<br />
二是可以用来查找多个单词组成的字符串，例如：  <br />
“jet plane”，如果不用双引号将其括起来，那么单词plane将被误认为是一个文件，查询结果将返回“文件不存在”的错误信息。<br />
在调用变量时，也应该使用双引号，诸如： grep “MYVAR”文件名，如果不这样，将没有返回结果。<br />
在调用模式匹配时，应使用单引号。  </p>

<p>常用的grep选项有：<br />
-c 只输出匹配行的计数。<br />
-i 不区分大小写（只适用于单字符）。<br />
-h 查询多文件时不显示文件名。<br />
-l 查询多文件时只输出包含匹配字符的文件名。<br />
-n 显示匹配行及行号。<br />
-s 不显示不存在或无匹配文本的错误信息。<br />
-v 显示不包含匹配文本的所有行。  </p>

<p>grep “will”*.doc 在当前目录下所有.doc文件中查找”will”字符串。  </p>

<p>精确匹配：<br />
grep “will<tab>"*.doc 在当前目录下所有.doc文件精确匹配"will"   还可以写为：grep "will\&gt;"*.doc  
大小写敏感：  
缺省情况下， grep是大小写敏感的，如要查询大小写不敏感字符串，必须使用- i开关。  </tab></p>


      <div class="readall"><a href="/blog/2015/02/01/Linux-point8.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point7.html">Linux学习笔记7-正则表达式介绍</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux7-">Linux学习笔记7-正则表达式介绍</h2>
<p>当从一个文件或命令输出中抽取或过滤文本时，可以使用正则表达式(RE)，正则表达式是一些特殊或不很特殊的字符串模式的集合。<br />
为了抽取或获得信息，我们给出抽取操作应遵守的一些规则。这些规则由一些特殊字符或进行模式匹配操作时使用的元字符组成。也可以使用规则字符作为模式中的一部分进行搜寻。<br />
例如，A将查询A，x将查找字母x  <br />
基本元字符<br />
^ 只只匹配行首<br />
$ 只只匹配行尾<br />
* 只一个单字符后紧跟*，匹配0个或多个此单字符<br />
[ ] 只匹配[ ]内字符。可以是一个单字符，也可以是字符序列。可以使用-表示[ ]内字符序列范围，如用[1-5]代替[12345]<br />
\ 只用来屏蔽一个元字符的特殊含义。因为有时在shell中一些元字符有
特殊含义。\可以使其失去应有意义<br />
. 只匹配任意单字符<br />
pattern{n} 只用来匹配前面pattern出现次数。n为次数<br />
pattern{n,} m 只含义同上，但次数最少为n<br />
pattern{n,m} 只含义同上，但pattern出现次数在n与m之间  </p>

<p>1.使用句点匹配单字符<br />
句点”.”可以匹配任意单字符。例如，如果要匹配一个字符串，以beg开头，中间夹一个任意字符，那么可以表示为beg.n，”.”可以匹配字符串头，也可以是中间任意字符。<br />
在ls -l命令中，可以匹配一定权限：<br />
…x..x ..x  : 匹配用户本身，用户组及其他组成员的执行权限。<br />
“.”允许匹配ASCII集中任意字符，或为字母，或为数字。<br />
2.在行首以^匹配字符串或字符序列<br />
^只允许在一行的开始匹配字符或单词。例如，使用ls -l命令，并匹配目录。之所以可以这样做是因为ls -l命令结果每行第一个字符是d，即代表一个目录。  <br />
^…4XC….  <br />
以上模式表示，在每行开始，匹配任意3个字符，后跟4XC，最后为任意4个字符。^在正则表达式中使用频繁，因为大量的抽取操作通常在行首.<br />
3.在行尾以$匹配字符串或字符  <br />
$与^正相反，它在行尾匹配字符串或字符， $符号放在匹配单词后。假定要匹配以单词test结尾的所有行，操作为：<br />
test$<br />
^$<br />
具体分析为匹配行首，又匹配行尾，中间没有任何模式，因此为空行。<br />
如果只返回包含一个字符的行，操作如下：<br />
^.$<br />
4.使用<em>匹配字符串中的单字符或其重复序列  <br />
使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：<br />
compu</em>t<br />
将匹配字符u一次或多次：<br />
compuut 
compuuut<br />
compuuuuut<br />
5.使用\屏蔽一个特殊字符的含义  <br />
有时需要查找一些字符或字符串，而它们包含了系统指定为特殊字符的一个字符。什么是特殊字符？一般意义上讲，下列字符可以认为是特殊字符：<br />
$ . ‘ “ * || ^ [] 0 \ + ?<br />
假定要匹配包含字符“ .”的各行而“，”代表匹配任意单字符的特殊字符，因此需要屏蔽其含义。操作如下：<br />
.
6.使用[]匹配一个范围或集合  <br />
使用[ ]匹配特定字符串或字符串集，可以用逗号将括弧内要匹配的不同字符串分开，但并不强制要求这样做（一些系统提倡在复杂的表达式中使用逗号），这样做可以增加模式的可读性。<br />
使用”-“表示一个字符串范围，表明字符串范围从”-“左边字符开始，到”-“右边字符结束。<br />
如果熟知一个字符串匹配操作，应经常使用[]模式。<br />
假定要匹配任意一个数字，可以使用：<br />
[0123456789]<br />
然而，通过使用“-”符号可以简化操作：<br />
[0-9]<br />
7.使用{}匹配模式结果出现的次数<br />
使用*可匹配所有匹配结果任意次，但如果只要指定次数，就应使用\ { \ }，此模式有三种形式，即：<br />
pattern{n} 匹配模式出现n次。<br />
pattern{n,} 匹配模式出现最少n次。<br />
pattern{n,m} 匹配模式出现n到m次之间，n , m为0 -255中任意整数。
请看第一个例子，匹配字母A出现两次，并以B结尾，操作如下：<br />
A{2}B<br />
匹配值为AAB<br />
匹配A至少4次，使用：<br />
A{4,} B<br />
可以得结果AAAAB或AAAAAAAB，但不能为AAAB。  </p>

      <div class="readall"><a href="/blog/2015/02/01/Linux-point7.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="pagination">
  
  <span class="pagination-item newer"><i class="fa fa-arrow-left"></i>&nbsp;&nbsp;上一页</span>
    
  
  <a class="pagination-item older" href="/page/2">下一页&nbsp;&nbsp;<i class="fa fa-arrow-right"></i></a>
  
</div>
    <footer>Copyright&nbsp;&copy;&nbsp;2015 <a href="index.html">willgo</a><br/><i class="fa fa-cogs" style="color:blueviolet;">&nbsp;</i>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>
</br> <a href="http://m.kuaidi100.com" target="_blank">快递查询</a> 
</footer>

    </div>
  </div>    
  <div id="top"><a id="rocket" href="javascript:;" title="返回顶部"><i></i></a></div>
  
</body>
</html>
