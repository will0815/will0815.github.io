<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RSS - willgo</title>
    <description>willgo - 最好的从未错过</description>
    <link>index.html</link>
    <atom:link href="index.html/page/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 24 May 2015 12:49:24 +0800</pubDate>
    <lastBuildDate>Sun, 24 May 2015 12:49:24 +0800</lastBuildDate>
    <generator>Will.Quan</generator>
    
      <item>
        <title>sqoop 特殊字符导入问题</title>
        <description>&lt;p&gt;Sqoop从MySQL导入数据到hive，示例：&lt;br /&gt;
sqoop import –connect  jdbc:mysql://10.255.2.89:3306/test?charset=utf-8 –  username selectuser –password select##select##  –table test_sqoop_import \&lt;br /&gt;
–columns ‘id,content,updateTime’ \&lt;br /&gt;
–split-by id \&lt;br /&gt;
–hive-import –hive-table basic.test2;  &lt;/p&gt;

&lt;p&gt;如果不加其他参数，导入的数据默认的列分隔符是’\001’，默认的行分隔符是’\n’。&lt;br /&gt;
这样问题就来了，如果导入的数据中有’\n’，hive会认为一行已经结束，后面的数据被分割成下一行。这种情况下，导入之后hive中数据的行数就比原先数据库中的多，而且会出现数据不一致的情况。&lt;br /&gt;
Sqoop也指定了参数 –fields-terminated-by和 –lines-terminated-by来自定义行分隔符和列分隔符。&lt;br /&gt;
可是当你真的这么做时 坑爹呀&lt;br /&gt;
INFO hive.HiveImport: FAILED: SemanticException 1:381 LINES TERMINATED BY only supports newline ’\n’ right now.    
也就是说虽然你通过–lines-terminated-by指定了其他的字符作为行分隔符，但是hive只支持’\n’作为行分隔符。&lt;br /&gt;
简单的解决办法就是加上参数–hive-drop-import-delims来把导入数据中包含的hive默认的分隔符去掉。  &lt;/p&gt;

&lt;p&gt;附 sqoop 命令参考  &lt;/p&gt;

&lt;p&gt;导入数据到 hdfs&lt;br /&gt;
使用 sqoop-import 命令可以从关系数据库导入数据到 hdfs。&lt;br /&gt;
$ sqoop import –connect jdbc:mysql://192.168.56.121:3306/metastore –username hiveuser –password redhat –table TBLS –target-dir /user/hive/result
注意：&lt;br /&gt;
mysql jdbc url 请使用 ip 地址&lt;br /&gt;
如果重复执行，会提示目录已经存在，可以手动删除&lt;br /&gt;
如果不指定 –target-dir，导入到用户家目录下的 TBLS 目录&lt;br /&gt;
你还可以指定其他的参数：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--append	将数据追加到hdfs中已经存在的dataset中。使用该参数，sqoop将把数据先导入到一个临时目录中，然后重新给文件命名到一个正式的目录中，以避免和该目录中已存在的文件重名。  
--as-avrodatafile	将数据导入到一个Avro数据文件中  
--as-sequencefile	将数据导入到一个sequence文件中  
--as-textfile	将数据导入到一个普通文本文件中，生成该文本文件后，可以在hive中通过sql语句查询出结果。  
--boundary-query &amp;lt;statement&amp;gt;	边界查询，也就是在导入前先通过SQL查询得到一个结果集，然后导入的数据就是该结果集内的数据，格式如：--boundary-query &#39;select id,no from t where id = 3&#39;，表示导入的数据为id=3的记录，或者 select min(&amp;lt;split-by&amp;gt;), max(&amp;lt;split-by&amp;gt;) from &amp;lt;table name&amp;gt;，注意查询的字段中不能有数据类型为字符串的字段，否则会报错
--columns&amp;lt;col,col&amp;gt;	指定要导入的字段值，格式如：--columns id,username
--direct	直接导入模式，使用的是关系数据库自带的导入导出工具。官网上是说这样导入会更快
--direct-split-size	在使用上面direct直接导入的基础上，对导入的流按字节数分块，特别是使用直连模式从PostgreSQL导入数据的时候，可以将一个到达设定大小的文件分为几个独立的文件。
--inline-lob-limit	设定大对象数据类型的最大值
-m,--num-mappers	启动N个map来并行导入数据，默认是4个，最好不要将数字设置为高于集群的节点数
--query，-e &amp;lt;sql&amp;gt;	从查询结果中导入数据，该参数使用时必须指定–target-dir、–hive-table，在查询语句中一定要有where条件且在where条件中需要包含 \$CONDITIONS，示例：--query &#39;select * from t where \$CONDITIONS &#39; --target-dir /tmp/t –hive-table t
--split-by &amp;lt;column&amp;gt;	表的列名，用来切分工作单元，一般后面跟主键ID
--table &amp;lt;table-name&amp;gt;	关系数据库表名，数据从该表中获取
--delete-target-dir	删除目标目录
--target-dir &amp;lt;dir&amp;gt;	指定hdfs路径
--warehouse-dir &amp;lt;dir&amp;gt;	与 --target-dir 不能同时使用，指定数据导入的存放目录，适用于hdfs导入，不适合导入hive目录
--where	从关系数据库导入数据时的查询条件，示例：--where &quot;id = 2&quot;
-z,--compress	压缩参数，默认情况下数据是没被压缩的，通过该参数可以使用gzip压缩算法对数据进行压缩，适用于SequenceFile, text文本文件, 和Avro文件
--compression-codec	Hadoop压缩编码，默认是gzip
--null-string &amp;lt;null-string&amp;gt;	可选参数，如果没有指定，则字符串null将被使用
--null-non-string &amp;lt;null-string&amp;gt;	可选参数，如果没有指定，则字符串null将被使用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 sql 语句&lt;br /&gt;
参照上表，使用 sql 语句查询时，需要指定 $CONDITIONS  &lt;/p&gt;

&lt;p&gt;$ sqoop import –connect jdbc:mysql://192.168.56.121:3306/metastore –username hiveuser –password redhat –query ‘SELECT * from TBLS where $CONDITIONS ‘ –split-by tbl_id -m 4 –target-dir /user/hive/result&lt;br /&gt;
	上面命令通过 -m 1 控制并发的 map 数。&lt;/p&gt;

&lt;p&gt;使用 direct 模式：&lt;br /&gt;
$ sqoop import –connect jdbc:mysql://192.168.56.121:3306/metastore –username hiveuser –password redhat –table TBLS –delete-target-dir –direct –default-character-set UTF-8 –target-dir /user/hive/result&lt;/p&gt;

&lt;p&gt;指定文件输出格式：&lt;br /&gt;
$ sqoop import –connect jdbc:mysql://192.168.56.121:3306/metastore –username hiveuser –password redhat –table TBLS –fields-terminated-by “\t” –lines-terminated-by “\n” –delete-target-dir  –target-dir /user/hive/result&lt;/p&gt;

&lt;p&gt;指定空字符串：&lt;br /&gt;
$ sqoop import –connect jdbc:mysql://192.168.56.121:3306/metastore –username hiveuser –password redhat –table TBLS –fields-terminated-by “\t” –lines-terminated-by “\n” –delete-target-dir –null-string ‘\N’ –null-non-string ‘\N’ –target-dir /user/hive/result&lt;/p&gt;

&lt;p&gt;如果需要指定压缩：  &lt;br /&gt;
$ sqoop import –connect jdbc:mysql://192.168.56.121:3306/metastore –username hiveuser –password redhat –table TBLS –fields-terminated-by “\t” –lines-terminated-by “\n” –delete-target-dir –null-string ‘\N’ –null-non-string ‘\N’ –compression-codec “com.hadoop.compression.lzo.LzopCodec” –target-dir /user/hive/result  &lt;/p&gt;

&lt;p&gt;附：可选的文件参数如下表。   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--enclosed-by &amp;lt;char&amp;gt;	给字段值前后加上指定的字符，比如双引号，示例：--enclosed-by &#39;\&quot;&#39;，显示例子：&quot;3&quot;,&quot;jimsss&quot;,&quot;dd@dd.com&quot;
--escaped-by &amp;lt;char&amp;gt;	给双引号作转义处理，如字段值为&quot;测试&quot;，经过 --escaped-by &quot;\\&quot; 处理后，在hdfs中的显示值为：\&quot;测试\&quot;，对单引号无效
--fields-terminated-by &amp;lt;char&amp;gt;	设定每个字段是以什么符号作为结束的，默认是逗号，也可以改为其它符号，如句号.，示例如：--fields-terminated-by
--lines-terminated-by &amp;lt;char&amp;gt;	设定每条记录行之间的分隔符，默认是换行串，但也可以设定自己所需要的字符串，示例如：--lines-terminated-by &quot;#&quot; 以#号分隔
--mysql-delimiters	Mysql默认的分隔符设置，字段之间以,隔开，行之间以换行\n隔开，默认转义符号是\，字段值以单引号&#39;包含起来。
--optionally-enclosed-by &amp;lt;char&amp;gt;	enclosed-by是强制给每个字段值前后都加上指定的符号，而--optionally-enclosed-by只是给带有双引号或单引号的字段值加上指定的符号，故叫可选的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 hive 表&lt;br /&gt;
生成与关系数据库表的表结构对应的HIVE表：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sqoop create-hive-table --connect jdbc:mysql://192.168.56.121:3306/metastore --username hiveuser --password redhat --table TBLS 
--hive-home &amp;lt;dir&amp;gt;	Hive的安装目录，可以通过该参数覆盖掉默认的hive目录
--hive-overwrite	覆盖掉在hive表中已经存在的数据
--create-hive-table	默认是false，如果目标表已经存在了，那么创建任务会失败
--hive-table	后面接要创建的hive表
--table	指定关系数据库表名  导入数据到 hive   执行下面的命令会将 mysql 中的数据导入到 hdfs 中，然后创建一个hive 表，最后再将 hdfs 上的文件移动到 hive 表的目录下面。   $ sqoop import --connect jdbc:mysql://192.168.56.121:3306/metastore --username hiveuser --password redhat --table TBLS --fields-terminated-by &quot;\t&quot; --lines-terminated-by &quot;\n&quot; --hive-import --hive-overwrite --create-hive-table --hive-table dw_srclog.TBLS --delete-target-dir   说明：   可以在 hive 的表名前面指定数据库名称   可以通过 --create-hive-table 创建表，如果表已经存在则会执行失败   从上面可见，数据导入到 hive 中之后分隔符为默认分隔符，参考上文你可以通过设置参数指定其他的分隔符。   另外，Sqoop 默认地导入空值（NULL）为 null 字符串，而 hive 使用 \N 去标识空值（NULL），故你在 import 或者 export 时候，需要做相应的处理。在 import 时，使用如下命令：   $ sqoop import  ... --null-string &#39;\\N&#39; --null-non-string &#39;\\N&#39;   在导出时，使用下面命令：   $ sqoop import  ... --input-null-string &#39;&#39; --input-null-non-string &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增量导入&lt;br /&gt;
–check-column (col)	用来作为判断的列名，如id&lt;br /&gt;
–incremental (mode)	append：追加，比如对大于last-value指定的值之后的记录进行追加导入。lastmodified：最后的修改时间，追加last-value指定的日期之后的记录&lt;br /&gt;
–last-value (value)	指定自从上次导入后列的最大值（大于该指定的值），也可以自己设定某一值&lt;/p&gt;

&lt;p&gt;合并 hdfs 文件&lt;br /&gt;
将HDFS中不同目录下面的数据合在一起，并存放在指定的目录中，示例如：&lt;br /&gt;
sqoop merge –new-data /test/p1/person –onto /test/p2/person –target-dir /test/merged –jar-file /opt/data/sqoop/person/Person.jar –class-name Person –merge-key id&lt;br /&gt;
其中，–class-name 所指定的 class 名是对应于 Person.jar 中的 Person 类，而 Person.jar 是通过 Codegen 生成的&lt;br /&gt;
–new-data &lt;path&gt;	Hdfs中存放数据的一个目录，该目录中的数据是希望在合并后能优先保留的，原则上一般是存放越新数据的目录就对应这个参数。  
--onto &lt;path&gt;	Hdfs中存放数据的一个目录，该目录中的数据是希望在合并后能被更新数据替换掉的，原则上一般是存放越旧数据的目录就对应这个参数。  
--merge-key &amp;lt;col&amp;gt;	合并键，一般是主键ID  
--jar-file &lt;file&gt;	合并时引入的jar包，该jar包是通过Codegen工具生成的jar包  
--class-name &lt;class&gt;	对应的表名或对象名，该class类是包含在jar包中的。  
--target-dir &lt;path&gt;	合并后的数据在HDFS里的存放目录  &lt;/path&gt;&lt;/class&gt;&lt;/file&gt;&lt;/path&gt;&lt;/path&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 16 May 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/05/16/sqoop-spacil-chart.html</link>
        <guid isPermaLink="true">index.html/blog/2015/05/16/sqoop-spacil-chart.html</guid>
        
        <category>hadoop</category>
        
      </item>
    
      <item>
        <title>hive 数据仓库优劣学习</title>
        <description>&lt;h5 id=&quot;hive&quot;&gt;Hive数据仓库优劣&lt;/h5&gt;
&lt;p&gt;Hive是一个基于Hadoop的数据仓库平台，通过Hive，可以方便地进行数据提取转化加载（ETL）的工作。Hive定义了一个类似于SQL的查询语言HQL，能够将用户编写的SQL转化为相应的MapReduce程序。当然，用户也可以自定义Mapper和Reducer来完成复杂的分析工作。&lt;br /&gt;
基于MapReduce的Hive具有良好的扩展性和容错性。不过由于MapReduce缺乏结构化数据分析中有价值的特性，以及Hive缺乏对执行计划的充分优化，导致Hive在很场景中执行效率不高。  &lt;/p&gt;

&lt;p&gt;强大的数据仓库和数据分析平台至少需要具备以下几点特性。&lt;br /&gt;
灵活的存储引擎&lt;br /&gt;
高效的执行引擎&lt;br /&gt;
良好的可扩展性&lt;br /&gt;
强大的容错机制&lt;br /&gt;
多样化的可视化  &lt;/p&gt;

&lt;h6 id=&quot;section&quot;&gt;#存储引擎&lt;/h6&gt;
&lt;p&gt;Hive数据存储没有特有的数据结构，（只是hdfs文件的映射）也没有为数据建立索引，可以自由地组织Hive中的表，只要在创建表时告诉Hive数据中的列分隔符和行分隔符，Hive就可以解析数据。Hive的元数据存储在RDBMS中，所有数据都基于HDFS存储。Hive包含Table、External Table、Partition和Bucket等数据模型。  &lt;/p&gt;

&lt;h6 id=&quot;section-1&quot;&gt;#执行引擎&lt;/h6&gt;
&lt;p&gt;Hive的编译器负责编译源代码并生成最终的执行计划，包括语法分析、语义分析、目标代码生成，所做的优化并不多。Hive基于MapReduce，Hive的Sort和GroupBy都依赖MapReduce。而MapReduce相当于固化了执行算子，Map的MergeSort必须执行，GroupBy算子也只有一种模式，Reduce的Merge-Sort也必须可选。另外Hive对Join算子的支持也较少。内存拷贝和数据预处理也会影响Hive的执行效率。&lt;br /&gt;
#######扩展性
Hive关注水平扩展性。简单来讲，水平扩展性指系统可以通过简单的增加资源来支持更大的数据量和负载。Hive处理的数据量是PB级的，而且每小时每天都在增长，这就使得水平扩展性成为一个非常重要的指标。Hadoop系统的水平扩展性是非常好的，而Hive基MapReduce框架，因此能够很自然地利用这点。
#######容错性
Hive有较好的容错性。Hive的执行计划在MapReduce框架上以作业的方式执行，每个作业的中间结果文件写到本地磁盘，最终输出文件写到HDFS文件系统，利用HDFS的多副本机制来保证数据的可靠性，从而达到作业的容错性。如果在作业执行过程中某节点出现故障，那么Hive执行计划基本不会受到影响。因此，基于Hive实现的数据仓库可以部署在由普通机器构建的分布式集群之上。
#######可视化
Hive的可视化界面基本属于字符终端，用户的技术水平一般比较高。面向不同的应用和用户，提供个性化的可视化展现，是Hive改进的一个重要方向。&lt;/p&gt;
</description>
        <pubDate>Sat, 16 May 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/05/16/hive-datahouse.html</link>
        <guid isPermaLink="true">index.html/blog/2015/05/16/hive-datahouse.html</guid>
        
        <category>hadoop</category>
        
      </item>
    
      <item>
        <title>MR中Join方案</title>
        <description>&lt;h4 id=&quot;mrjoin&quot;&gt;MR中Join方案&lt;/h4&gt;
&lt;p&gt;与传统数据一样在MR中的join操作也是一项耗时的操作，但是我们可以根据MR 的设计思想对其进行优化。&lt;br /&gt;
#######Reduce side join&lt;br /&gt;
这是最简单的一种形式，主要思想：&lt;br /&gt;
在map阶段，map函数同时读取两个文件File1和File2，为了区分两种来源的key/value数据对，对每条数据打一个标签（tag）,比如：tag=0表示来自文件File1，tag=2表示来自文件File2。即：map阶段的主要任务是对不同文件中的数据打标签。&lt;br /&gt;
在reduce阶段，reduce函数获取key相同的来自File1和File2文件的value list， 然后对于同一个key，对File1和File2中的数据进行join（笛卡尔乘积）。即：reduce阶段进行实际的连接操作。这种形式主要是利用hadoop mr 的框架机制。  &lt;/p&gt;

&lt;h6 id=&quot;map-side-join&quot;&gt;#Map side join&lt;/h6&gt;
&lt;p&gt;reduce side join，是因为在map阶段不能获取所有需要的join字段，即：同一个key对应的字段可能位于不同map中。Reduce side join是非常低效的，因为shuffle阶段要进行大量的数据传输。&lt;br /&gt;
Map side join是针对以下场景进行的优化：两个待连接表中，有一个表非常大，而另一个表非常小，以至于小表可以直接存放到内存中。这样，我们可以将小表复制多份，让每个map task内存中存在一份（比如存放到hash table中），然后只扫描大表：对于大表中的每一条记录key/value，在hash table中查找是否有相同的key的记录，如果有，则连接后输出即可。&lt;br /&gt;
为了支持文件的复制，&lt;br /&gt;
Hadoop提供了一个类DistributedCache，使用该类的方法如下：&lt;br /&gt;
（1）用户使用静态方法DistributedCache.addCacheFile(URI)指定要复制的文件。JobTracker在作业启动之前会获取这个URI列表，并将相应的文件拷贝到各个TaskTracker的本地磁盘上。&lt;br /&gt;
（2）用户使用DistributedCache.getLocalCacheFiles()方法获取文件目录，并使用标准的文件读写API读取相应的文件。&lt;br /&gt;
如果足够小 也可以 放在context里面（不推荐）&lt;br /&gt;
#######Semi Join&lt;br /&gt;
Semi Join，也叫半连接，是从分布式数据库中借鉴过来的方法。它的产生动机是：对于reduce side join，跨机器的数据传输量非常大，这成了join操作的一个瓶颈，如果能够在map端过滤掉不会参加join操作的数据，则可以大大节省网络IO。&lt;br /&gt;
实现方法很简单：选取一个小表，假设是File1，将其参与join的key抽取出来，保存到文件File3中，File3文件一般很小，可以放到内存中。在map阶段，使用DistributedCache将File3复制到各个TaskTracker上，然后将File2中不在File3中的key对应的记录过滤掉，剩下的reduce阶段的工作与reduce side join相同。&lt;br /&gt;
#######reduce side join + BloomFilter&lt;br /&gt;
在某些情况下，SemiJoin抽取出来的小表的key集合在内存中仍然存放不下，这时候可以使用BloomFiler以节省空间。&lt;br /&gt;
BloomFilter最常见的作用是：判断某个元素是否在一个集合里面。它最重要的两个方法是：add() 和contains()。最大的特点是不会存在 false negative，即：如果contains()返回false，则该元素一定不在集合中，但会存在一定的 false positive，即：如果contains()返回true，则该元素一定可能在集合中。因而可将小表中的key保存到BloomFilter中，在map阶段过滤大表，可能有一些不在小表中的记录没有过滤掉（但是在小表中的记录一定不会过滤掉），这没关系，只不过增加了少量的网络IO而已。&lt;br /&gt;
#######二次排序
在Hadoop中，默认情况下是按照key进行排序，如果要按照value进行排序怎么办？即：对于同一个key，reduce函数接收到的value list是按照value排序的。这种应用需求在join操作中很常见，比如，希望相同的key中，小表对应的value排在前面。&lt;br /&gt;
有两种方法进行二次排序，分别为：buffer and in memory sort和 value-to-key conversion。
对于buffer and in memory sort，主要思想是：在reduce()函数中，将某个key对应的所有value保存下来，然后进行排序。 这种方法最大的缺点是：可能会造成out of memory。&lt;br /&gt;
对于value-to-key conversion，主要思想是：将key和部分value拼接成一个组合key（实现WritableComparable接口或者调用setSortComparatorClass函数），这样reduce获取的结果便是先按key排序，后按value排序的结果，需要注意的是，用户需要自己实现Paritioner，以便只按照key进行数据划分。&lt;br /&gt;
Hadoop显式的支持二次排序，在Configuration类中有个setGroupingComparatorClass()方法，可用于设置排序group的key值
实际工作多数情况下，会采用第一种，reduce side join 简单 安全  。。。。  &lt;/p&gt;

</description>
        <pubDate>Sat, 16 May 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/05/16/MR-join.html</link>
        <guid isPermaLink="true">index.html/blog/2015/05/16/MR-join.html</guid>
        
        <category>hadoop</category>
        
      </item>
    
      <item>
        <title>DB演进理解</title>
        <description>&lt;h2 id=&quot;db&quot;&gt;DB演进理解&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;RDBMS&lt;br /&gt;
这是最熟悉的数据存储方式，一般情况下数据存储在一台机器上，这种形式方便提供完善ACID特性和丰富查询模型。这就是传统的关系型数据库的基础模式，但是面对现如今越来越大的数据量，这种模式的扩展变得难以满足。实践证明通过增加节点这种简单廉价的扩展方式是可行的。RDBMS的横向扩展主要有主从复制（Master-slave）、分表、分区等。 &lt;br /&gt;
横向扩展RDBMS – Master/Slave &lt;br /&gt;
利用数据库的复制或镜像功能，同时在多台数据库上保存相同的数据，从而将读操作和写操作分开，写操作集中在一台主数据库上，读操作集中在多台从数据库上。&lt;br /&gt;
问题：&lt;br /&gt;
读写同步需要一定的时间，导致关键的读取有出错风险；&lt;br /&gt;
主节点将数据复制到从节点，数据量很大是可能造成问题，  &lt;/p&gt;

    &lt;p&gt;横向扩展RDBMS - Sharding &lt;br /&gt;
 在满足ACID特性的数据库中进行扩展是非常难的。基于这个原因，对数据进行扩展，这个数据库本身就必须拥有简单的模型，将数据分割为N片，然后在单独的片中执行查询。数据分割的单元被称为“shard”。将N片数据分配个M个DBMS进行操作。DBMS并不会去管理数据片，程序开发负责数据片的处理。
 不同的分片方法有：&lt;br /&gt;
 - 垂直分区（Vertical Partitioning）：将不需要进行联合查询的数据表分散到不同的数据库服务器上。&lt;br /&gt;
 - 水平分区(sharding) 将同一个表的记录拆分到不同的表甚至是服务器上，这往往需要一个稳定的算法来保证读取时能正确从不同的服务器上取得数据。如Range-Based Partitioning, Key or Hash-Based partitioning等。&lt;br /&gt;
 优点与不足&lt;br /&gt;
 - 对读取和写入都有很好的扩展&lt;br /&gt;
 - 不透明，程序需要识别分区 &lt;br /&gt;
 - 不再有跨分区的关系/joins &lt;br /&gt;
 - 参照完整性损失  &lt;/p&gt;

    &lt;p&gt;其他RDBMS扩展方法 &lt;br /&gt;
 Multi-Master replication：所有成员都响应客户端数据查询。多主复制系统负责将任意成员做出的数据更新传播给组内其他成员，并解决不同成员间并发修改可能带来的冲突。&lt;br /&gt;
 INSERT only, not UPDATES/DELETES：数据进行版本化处理。&lt;br /&gt;
 No JOINs, thereby reducing query time：Join的开销很大,而且频繁访问会使开销随着时间逐渐增加。&lt;br /&gt;
 非规范化（Denormalization）可以降低数据仓库的复杂性，以提高效率和改善性能。&lt;br /&gt;
 In-memory databases：磁盘数据库解决的是大容量存储和数据分析问题，内存数据库解决的是实时处理和高并发问题。主流常规的RDBMS更多的是磁盘密集型，而不是内存密集型。  &lt;/p&gt;

    &lt;p&gt;ACID Transactions&lt;br /&gt;
 一个完善的数据库系统都是希望支持“ACID transactions,”其包括:&lt;br /&gt;
 Atomic : Either the whole process is done or none is.（原子性）&lt;br /&gt;
 Consistent : Database constraints are preserved.（一致性）&lt;br /&gt;
 Isolated : It appears to the user as if only one process executes at a time.（隔离性）&lt;br /&gt;
 Durable : Effects of a process do not get lost if the system crashes.（持久性）  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NoSQL  &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;NoSQL现在被理解为 Not Only SQL 的缩写，是对非关系型的数据库管理系统的统称
NoSQL 与 RDBMS 不同点，&lt;br /&gt;
-不使用SQL作为查询语言。&lt;br /&gt;
-不需要固定的表模式(table schema)。&lt;br /&gt;
- 放宽一个或多个 ACID 属性（CAP定理）  &lt;/p&gt;

&lt;p&gt;补充：CAP理论&lt;br /&gt;
CAP理论是数据系统设计的基本理论，目前几乎所有的数据系统的设计都遵循了这个理论。CAP理论指出，分布式系统只能满足以下三项中的两项而不可能满足全部三项，&lt;br /&gt;
一致性（Consistency)（所有节点在同一时间具有相同的数据）&lt;br /&gt;
可用性（Availability）（保证每个请求不管成功或者失败都有响应）&lt;br /&gt;
分区容忍性（Partition tolerance）（系统中任意信息的丢失或失败不会影响系统的继续运作） &lt;/p&gt;

&lt;p&gt;一致性有两种类型：&lt;br /&gt;
- strong consistency – ACID(Atomicity Consistency Isolation Durability)：对于关系型数据库，要求更新过的数据能被后续所有的访问都看到，这是强一致性。&lt;br /&gt;
- weak consistency – BASE(Basically Available Soft-state Eventual consistency )
– Basically Available - system seems to work all the time (基本可用)&lt;br /&gt;
– Soft State - it doesn’t have to be consistent all the time （不要求所有时间都一致）&lt;br /&gt;
– Eventually Consistent - becomes consistent at some later time （最终一致性）  &lt;/p&gt;

&lt;p&gt;对于分布式数据系统(scale out)，分区容忍性是基本要求，否则就失去了价值。因此只能在一致性和可用性上做取舍，如何处理这种取舍正是目前NoSQL数据库的核心焦点。牺牲一致性而换取高可用性。当然，牺牲一致性，只是不再要求关系数据库中的强一致性，而是只要系统能达到最终一致性即可。通常是通过数据的多份异步复制来实现系统的高可用和数据的最终一致性的。  &lt;/p&gt;

&lt;p&gt;NoSQL 的两种主要实现方式&lt;br /&gt;
1.Key/Value&lt;br /&gt;
Amazon S3 (Dynamo)&lt;br /&gt;
Voldemort &lt;br /&gt;
Scalaris &lt;br /&gt;
Memcached (in-memory key/value store)&lt;br /&gt;
Redis &lt;br /&gt;
2. 弱模式型（column-based, document-based or graph-based.）&lt;br /&gt;
Cassandra (column-based)&lt;br /&gt;
CouchDB (document-based)&lt;br /&gt;
MongoDB(document-based) &lt;br /&gt;
Neo4J (graph-based)&lt;br /&gt;
HBase (column-based)   &lt;/p&gt;

&lt;p&gt;K/V模式&lt;br /&gt;
优点:&lt;br /&gt;
very fast&lt;br /&gt;
very scalable&lt;br /&gt;
simple model&lt;br /&gt;
able to distribute horizontally&lt;br /&gt;
劣势: &lt;br /&gt;
 many data structures (objects) can’t be easily modeled as key value pairs （需要多余转换）&lt;br /&gt;
Schema-Less 模式&lt;br /&gt;
优点&lt;br /&gt;
Schema-less data model is richer than key/value pairs
eventual consistency&lt;br /&gt;
many are distributed&lt;br /&gt;
still provide excellent performance and scalability&lt;br /&gt;
劣势&lt;br /&gt;
typically no ACID transactions or joins  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HBase  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HBase is an open-source, distributed, column-oriented database built on top of HDFS (or KFS) based on BigTable! &lt;br /&gt;
按照CAP理论，HBase属于C+P类型的系统。HBase是强一致性的（仅支持单行事务）。每一行由单个区域服务器（region server）host，行锁（row locks）和多版本并发控制(multiversion concurrency control)的组合被用来保证行的一致性。&lt;br /&gt;
查找:&lt;br /&gt;
快速定位使用row key + column family + column + timestamp.&lt;br /&gt;
按范围查找：start row key – end row key.&lt;br /&gt;
全表扫描&lt;br /&gt;
交互方式&lt;br /&gt;
- Java, REST, or Thrift APIs.&lt;br /&gt;
- Scripting via JRuby.  &lt;/p&gt;

&lt;p&gt;HBase 一些特性  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- No real indexes（row key 即数据的索引）  
- Automatic partitioning（region自动split）  
- Scale linearly and automatically with new nodes（扩展容易 节点添加方便）  
- Commodity hardware（廉价硬件）  
- Fault tolerance(较强的容错性)  
- Batch processing(批处理能力优秀)  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Hive    &lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Provide higher-level language (HQL, like SQL) to facilitate large-data processing&lt;/li&gt;
      &lt;li&gt;Higher-level language “compiles down” to Hadoop Map/Reduce jobs&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hive + HBase  &lt;/p&gt;

    &lt;p&gt;Reasons to use Hive on HBase:&lt;br /&gt;
 A lot of data sitting in HBase due to its usage in a real-time environment, but never used for analysis&lt;br /&gt;
 Give access to data in HBase usually only queried through MapReduce to people that don’t code (business analysts)&lt;br /&gt;
 When needing a more flexible storage solution, so that rows can be updated live by either a Hive job or an application and can be seen immediately to the other&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 16 May 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/05/16/DB-yanjin.html</link>
        <guid isPermaLink="true">index.html/blog/2015/05/16/DB-yanjin.html</guid>
        
        <category>db</category>
        
      </item>
    
      <item>
        <title>CDH 安装问题</title>
        <description>&lt;p&gt;&lt;em&gt;CDH5安装参照：http://www.tuicool.com/articles/ENjmeaY&lt;/em&gt;&lt;br /&gt;
Q1:安装过程中提示找不到MySQL 驱动jar包&lt;br /&gt;
	：在/usr/shar/java 中添加mysql-connector-java-5.1.30-bin.jar&lt;br /&gt;
Q2：安装hive提示找不到MySQL驱动jar包&lt;br /&gt;
：在/opt/cloudera/parcels/CDH-5.1.3-1.cdh5.1.3.p0.12/lib/hive/lib/ 中添加 mysql-connector-java-5.1.30-bin.jar&lt;br /&gt;
Q3: cloudera-server 或cloudera-agent  status 提示服务已经停止，pid仍然存在&lt;br /&gt;
	：查看对应的log 可能是端口占用或是数据库连接问题&lt;br /&gt;
Q4:MR2和HDFS安装好后 web ui无法访问，查看对应端口已经处于listen状态，&lt;br /&gt;
	：分别在对应的配置中的端口和地址选项中将“将 ResourceManager 绑定到通配符地址”项， 勾选上&lt;br /&gt;
没有这个选项的可以在高级设置中在XML文件中添加&lt;br /&gt;
Q5：jdk版本不对应&lt;br /&gt;
	： CDH默认获取的jdk 位于：/usr/java   可将需要的jdk 拷贝到这个目录中。  &lt;/p&gt;

&lt;p&gt;Q6  sqoop导入数据时：User does not belong to hive&lt;br /&gt;
	I had same issue with permissions -&amp;gt; chgrp: changing ownership of ‘/user/hive/warehouse/test/_log24310.txt’: User does not belong to hive.
1.Added the existing user named cloudera to existing group named hive with command: usermod -a -G hive cloudera 
2.Restarted the system 
3.Used Load Command and after that did a select * from table_name -&amp;gt; No data was getting displayed. 
4.Executed select count(*) from table_name and a MapReduce job got started. 
5.Executed select * from table and now results was returned correctly. 
6.Opened a impala shell using impala-shell command. 
7.Executed a select * from table_name and no results was getting returned. 
8.Executed command invalidate metadata in the impala-shell 
9.Executed command refresh table_name 
10.Executed command show tables 
11.Executed command select * from table_name and now results are getting displayed both in the impala-shell and hive shell. 
  可以不必理会&lt;/p&gt;

&lt;p&gt;Q6：spark 安装不上&lt;br /&gt;
	未解决，网上有对应bug&lt;/p&gt;

&lt;p&gt;整个安装过程中遇到各种问题，主要解决得途径还是查看对应的log文件对应解决：&lt;br /&gt;
/var/log/hadoop*&lt;br /&gt;
/var/log/cloudera*&lt;br /&gt;
/opt/cm-5.1.3/log  &lt;/p&gt;

&lt;h6 id=&quot;about&quot;&gt;===========================about==================================================================================================================================&lt;/h6&gt;
&lt;p&gt;问题导读  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.CM的安装目录在什么位置？  
2.hadoop配置文件在什么位置？  
3.Cloudera manager运行所需要的信息存在什么位置？  
4.CM结构和功能是什么？  
1. 相关目录  
/var/log/cloudera-scm-installer : 安装日志目录。  
/var/log/* : 相关日志文件（相关服务的及CM的）。  
/usr/share/cmf/ : 程序安装目录。  
/usr/lib64/cmf/ : Agent程序代码。  
/var/lib/cloudera-scm-server-db/data : 内嵌数据库目录。  
/usr/bin/postgres : 内嵌数据库程序。  
/etc/cloudera-scm-agent/ : agent的配置目录。  
/etc/cloudera-scm-server/ : server的配置目录。  
/opt/cloudera/parcels/ : Hadoop相关服务安装目录。  
/opt/cloudera/parcel-repo/ : 下载的服务软件包数据，数据格式为parcels。  
/opt/cloudera/parcel-cache/ : 下载的服务软件包缓存数据。  
/etc/hadoop/* : 客户端配置文件目录。  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;配置    &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hadoop配置文件&lt;br /&gt;
配置文件放置于/var/run/cloudera-scm-agent/process/目录下。如：/var/run/cloudera-scm-agent/process/193-hdfs-NAMENODE/core-site.xml。这些配置文件是通过Cloudera Manager启动相应服务（如HDFS）时生成的，内容从数据库中获得（即通过界面配置的参数）。&lt;br /&gt;
在CM界面上更改配置是不会立即反映到配置文件中，这些信息会存储于数据库中，等下次重启服务时才会生成配置文件。且每次启动时都会产生新的配置文件。&lt;br /&gt;
CM Server主要数据库为scm基中放置配置的数据表为configs。里面包含了服务的配置信息，每一次配置的更改会把当前页面的所有配置内容添加到数据库中，以此保存配置修改历史。&lt;br /&gt;
scm数据库被配置成只能从localhost访问，如果需要从外部连接此数据库，修改vim /var/lib/cloudera-scm-server-db/data/pg_hba.conf文件,之后重启数据库。运行数据库的用户为cloudera-scm。  &lt;/p&gt;

&lt;p&gt;查看配置内容&lt;br /&gt;
1.直接查询scm数据库的configs数据表的内容。  &lt;br /&gt;
2.访问REST API： http://hostname:7180/api/v4/cm/deployment，返回JSON格式部署配置信息。  &lt;/p&gt;

&lt;p&gt;配置生成方式&lt;br /&gt;
CM为每个服务进程生成独立的配置目录（文件）。所有配置统一在服务端查询数据库生成（因为scm数据库只能在localhost下访问）生成配置文件，再由agent通过网络下载包含配置文件的zip包到本地解压到指定的目录。  &lt;/p&gt;

&lt;p&gt;配置修改&lt;br /&gt;
CM对于需要修改的配置预先定义，对于没有预先定义的配置,则通过在高级配置项中使用xml配置片段的方式进行配置。而对于/etc/hadoop/下的配置文件是客户端的配置，可以在CM通过部署客户端生成客户端配置。  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据库&lt;br /&gt;
Cloudera manager主要的数据库为scm,存储Cloudera manager运行所需要的信息：配置，主机，用户等。  &lt;/li&gt;
  &lt;li&gt;CM结构 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CM分为Server与Agent两部分及数据库（自带更改过的嵌入Postgresql）。它主要做三件事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.管理监控集群主机。
2.统一管理配置。
3.管理维护Hadoop平台系统。
实现采用C/S结构，Agent为客户端负责执行服务端发来的命令，执行方式一般为使用python调用相应的服务shell脚本。Server端为Java REST服务，提供REST API，Web管理端通过REST API调用Server端功能，Web界面使用富客户端技术（Knockout）。
1.Server端主体使用Java实现。
2.Agent端主体使用Python, 服务的启动通过调用相应的shell脚本进行启动，如果启动失败会重复4次调用启动脚本。
3.Agent与Server保持心跳，使用Thrift RPC框架。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;升级  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在CM中可以通过界面向导升级相关服务。升级过程为三步：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.下载服务软件包。
2.把所下载的服务软件包分发到集群中受管的机器上。
3.安装服务软件包，使用软链接的方式把服务程序目录链接到新安装的软件包目录上。
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;卸载  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;sudo /usr/share/cmf/uninstall-scm-express.sh, 然后删除/var/lib/cloudera-scm-server-db/目录，不然下次安装可能不成功。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;开启postgresql远程访问  &lt;/p&gt;

    &lt;p&gt;CM内嵌数据库被配置成只能从localhost访问，如果需要从外部查看数据，数据修改vim /var/lib/cloudera-scm-server-db/data/pg_hba.conf文件,之后重启数据库。运行数据库的用户为cloudera-scm。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 16 May 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/05/16/CDH-install-question.html</link>
        <guid isPermaLink="true">index.html/blog/2015/05/16/CDH-install-question.html</guid>
        
        <category>hadoop</category>
        
      </item>
    
      <item>
        <title>Linux学习笔记9-AWK</title>
        <description>&lt;h2 id=&quot;linux9-awk&quot;&gt;Linux学习笔记9-AWK&lt;/h2&gt;
&lt;p&gt;AWK是所有shell过滤工具中最难掌握的，不知道为什么，也许是其复杂的语法或含义不明确的错误提示信息。在学习awk语言过程中，就会慢慢掌握诸如Bailing out 和awk:cmd.Line:等错误信息。可以说awk是一种自解释的编程语言，之所以要在shell中使用awk是因为awk本身是学习的好例子，但结合awk与其他工具诸如grep和sed，将会使shell编程更加
容易。&lt;br /&gt;
调用：&lt;br /&gt;
有三种方式调用awk，第一种是命令行方式，如：&lt;br /&gt;
awk [-F field-separator] ‘awk命令’ input-file(s)&lt;br /&gt;
[-F域分隔符]是可选的，因为awk使用空格作为缺省的域分隔符，因此如果
要浏览域间有空格的文本，不必指定这个选项，但如果要浏览诸如passwd文件，此文件各域以冒号作为分隔符，则必须指明- F选项&lt;br /&gt;
awk -F:’awk命令’ input-file&lt;br /&gt;
第二种方法是将所有awk命令插入一个文件，并使awk程序可执行，然后用awk命令解释器作为脚本的首行，以便通过键入脚本名称来调用它&lt;br /&gt;
awk -f awk-script-file input-files&lt;br /&gt;
第三种方式是将所有的awk命令插入一个单独文件. -f选项指明在文件awk_scriptfile中的awk脚本，inputfile(s)是使用awk进行浏览的文件
名。  &lt;/p&gt;

&lt;p&gt;awk脚本&lt;br /&gt;
在命令中调用awk时，awk脚本由各种操作和模式组成。&lt;br /&gt;
如果设置了-F选项，则awk每次读一条记录或一行，并使用指定的分隔符分隔指定域，但如果未设置-F选项，awk假定空格为域分隔符，并保持这个设置直到发现一新行。当新行出现时，awk命令获悉已读完整条记录，然后在下一个记录启动读命令，这个读进程将持续到文件尾或文件不再存在。&lt;/p&gt;

</description>
        <pubDate>Sun, 01 Feb 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/02/01/Linux-point9.html</link>
        <guid isPermaLink="true">index.html/blog/2015/02/01/Linux-point9.html</guid>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux学习笔记8-grep 家族</title>
        <description>&lt;h2 id=&quot;linux8-grep-&quot;&gt;Linux学习笔记8-grep 家族&lt;/h2&gt;
&lt;p&gt;grep（全局正则表达式版本）允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行。grep支持基本正则表达式，也支持其扩展集   &lt;br /&gt;
grep一般格式为：&lt;br /&gt;
grep [选项]基本正则表达式[文件]&lt;br /&gt;
这里基本正则表达式可为字符串。  &lt;/p&gt;

&lt;p&gt;在grep命令中输入字符串参数时，最好将其用双引号括起来。例如：“mystring”。这样做有两个原因，
一是以防被误解为shell命令，&lt;br /&gt;
二是可以用来查找多个单词组成的字符串，例如：  &lt;br /&gt;
“jet plane”，如果不用双引号将其括起来，那么单词plane将被误认为是一个文件，查询结果将返回“文件不存在”的错误信息。&lt;br /&gt;
在调用变量时，也应该使用双引号，诸如： grep “MYVAR”文件名，如果不这样，将没有返回结果。&lt;br /&gt;
在调用模式匹配时，应使用单引号。  &lt;/p&gt;

&lt;p&gt;常用的grep选项有：&lt;br /&gt;
-c 只输出匹配行的计数。&lt;br /&gt;
-i 不区分大小写（只适用于单字符）。&lt;br /&gt;
-h 查询多文件时不显示文件名。&lt;br /&gt;
-l 查询多文件时只输出包含匹配字符的文件名。&lt;br /&gt;
-n 显示匹配行及行号。&lt;br /&gt;
-s 不显示不存在或无匹配文本的错误信息。&lt;br /&gt;
-v 显示不包含匹配文本的所有行。  &lt;/p&gt;

&lt;p&gt;grep “will”*.doc 在当前目录下所有.doc文件中查找”will”字符串。  &lt;/p&gt;

&lt;p&gt;精确匹配：&lt;br /&gt;
grep “will&lt;tab&gt;&quot;*.doc 在当前目录下所有.doc文件精确匹配&quot;will&quot;   还可以写为：grep &quot;will\&amp;gt;&quot;*.doc  
大小写敏感：  
缺省情况下， grep是大小写敏感的，如要查询大小写不敏感字符串，必须使用- i开关。  &lt;/tab&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 01 Feb 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/02/01/Linux-point8.html</link>
        <guid isPermaLink="true">index.html/blog/2015/02/01/Linux-point8.html</guid>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux学习笔记7-正则表达式介绍</title>
        <description>&lt;h2 id=&quot;linux7-&quot;&gt;Linux学习笔记7-正则表达式介绍&lt;/h2&gt;
&lt;p&gt;当从一个文件或命令输出中抽取或过滤文本时，可以使用正则表达式(RE)，正则表达式是一些特殊或不很特殊的字符串模式的集合。&lt;br /&gt;
为了抽取或获得信息，我们给出抽取操作应遵守的一些规则。这些规则由一些特殊字符或进行模式匹配操作时使用的元字符组成。也可以使用规则字符作为模式中的一部分进行搜寻。&lt;br /&gt;
例如，A将查询A，x将查找字母x  &lt;br /&gt;
基本元字符&lt;br /&gt;
^ 只只匹配行首&lt;br /&gt;
$ 只只匹配行尾&lt;br /&gt;
* 只一个单字符后紧跟*，匹配0个或多个此单字符&lt;br /&gt;
[ ] 只匹配[ ]内字符。可以是一个单字符，也可以是字符序列。可以使用-表示[ ]内字符序列范围，如用[1-5]代替[12345]&lt;br /&gt;
\ 只用来屏蔽一个元字符的特殊含义。因为有时在shell中一些元字符有
特殊含义。\可以使其失去应有意义&lt;br /&gt;
. 只匹配任意单字符&lt;br /&gt;
pattern{n} 只用来匹配前面pattern出现次数。n为次数&lt;br /&gt;
pattern{n,} m 只含义同上，但次数最少为n&lt;br /&gt;
pattern{n,m} 只含义同上，但pattern出现次数在n与m之间  &lt;/p&gt;

&lt;p&gt;1.使用句点匹配单字符&lt;br /&gt;
句点”.”可以匹配任意单字符。例如，如果要匹配一个字符串，以beg开头，中间夹一个任意字符，那么可以表示为beg.n，”.”可以匹配字符串头，也可以是中间任意字符。&lt;br /&gt;
在ls -l命令中，可以匹配一定权限：&lt;br /&gt;
…x..x ..x  : 匹配用户本身，用户组及其他组成员的执行权限。&lt;br /&gt;
“.”允许匹配ASCII集中任意字符，或为字母，或为数字。&lt;br /&gt;
2.在行首以^匹配字符串或字符序列&lt;br /&gt;
^只允许在一行的开始匹配字符或单词。例如，使用ls -l命令，并匹配目录。之所以可以这样做是因为ls -l命令结果每行第一个字符是d，即代表一个目录。  &lt;br /&gt;
^…4XC….  &lt;br /&gt;
以上模式表示，在每行开始，匹配任意3个字符，后跟4XC，最后为任意4个字符。^在正则表达式中使用频繁，因为大量的抽取操作通常在行首.&lt;br /&gt;
3.在行尾以$匹配字符串或字符  &lt;br /&gt;
$与^正相反，它在行尾匹配字符串或字符， $符号放在匹配单词后。假定要匹配以单词test结尾的所有行，操作为：&lt;br /&gt;
test$&lt;br /&gt;
^$&lt;br /&gt;
具体分析为匹配行首，又匹配行尾，中间没有任何模式，因此为空行。&lt;br /&gt;
如果只返回包含一个字符的行，操作如下：&lt;br /&gt;
^.$&lt;br /&gt;
4.使用&lt;em&gt;匹配字符串中的单字符或其重复序列  &lt;br /&gt;
使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：&lt;br /&gt;
compu&lt;/em&gt;t&lt;br /&gt;
将匹配字符u一次或多次：&lt;br /&gt;
compuut 
compuuut&lt;br /&gt;
compuuuuut&lt;br /&gt;
5.使用\屏蔽一个特殊字符的含义  &lt;br /&gt;
有时需要查找一些字符或字符串，而它们包含了系统指定为特殊字符的一个字符。什么是特殊字符？一般意义上讲，下列字符可以认为是特殊字符：&lt;br /&gt;
$ . ‘ “ * || ^ [] 0 \ + ?&lt;br /&gt;
假定要匹配包含字符“ .”的各行而“，”代表匹配任意单字符的特殊字符，因此需要屏蔽其含义。操作如下：&lt;br /&gt;
.
6.使用[]匹配一个范围或集合  &lt;br /&gt;
使用[ ]匹配特定字符串或字符串集，可以用逗号将括弧内要匹配的不同字符串分开，但并不强制要求这样做（一些系统提倡在复杂的表达式中使用逗号），这样做可以增加模式的可读性。&lt;br /&gt;
使用”-“表示一个字符串范围，表明字符串范围从”-“左边字符开始，到”-“右边字符结束。&lt;br /&gt;
如果熟知一个字符串匹配操作，应经常使用[]模式。&lt;br /&gt;
假定要匹配任意一个数字，可以使用：&lt;br /&gt;
[0123456789]&lt;br /&gt;
然而，通过使用“-”符号可以简化操作：&lt;br /&gt;
[0-9]&lt;br /&gt;
7.使用{}匹配模式结果出现的次数&lt;br /&gt;
使用*可匹配所有匹配结果任意次，但如果只要指定次数，就应使用\ { \ }，此模式有三种形式，即：&lt;br /&gt;
pattern{n} 匹配模式出现n次。&lt;br /&gt;
pattern{n,} 匹配模式出现最少n次。&lt;br /&gt;
pattern{n,m} 匹配模式出现n到m次之间，n , m为0 -255中任意整数。
请看第一个例子，匹配字母A出现两次，并以B结尾，操作如下：&lt;br /&gt;
A{2}B&lt;br /&gt;
匹配值为AAB&lt;br /&gt;
匹配A至少4次，使用：&lt;br /&gt;
A{4,} B&lt;br /&gt;
可以得结果AAAAB或AAAAAAAB，但不能为AAAB。  &lt;/p&gt;
</description>
        <pubDate>Sun, 01 Feb 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/02/01/Linux-point7.html</link>
        <guid isPermaLink="true">index.html/blog/2015/02/01/Linux-point7.html</guid>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux学习笔记6-命令执行顺序</title>
        <description>&lt;h2 id=&quot;linux6-&quot;&gt;Linux学习笔记6-命令执行顺序&lt;/h2&gt;
&lt;p&gt;场景：执行某个命令的时候，有时需要依赖于前一个命令是否执行成功。例如，假设你希望&lt;br /&gt;
将一个目录中的文件全部拷贝到另外一个目录中后，然后删除源目录中的全部文件。在删除之前，你希望能够确信拷贝成功，否则就有可能丢失所有的文件。  &lt;br /&gt;
1.&amp;amp;&amp;amp;&lt;br /&gt;
&amp;amp;&amp;amp;的一般形式：&lt;br /&gt;
命令1 &amp;amp;&amp;amp; 命令2&lt;br /&gt;
以上表示：命令1返回真(返回0，成功执行)后，命令2才能被执行&lt;br /&gt;
如：mv /apps/bin /apps/dev/bin &amp;amp;&amp;amp; rm -r /apps/bin&lt;br /&gt;
2.||  &lt;br /&gt;
||一般形式：&lt;br /&gt;
命令1||命令2&lt;br /&gt;
以上表示：命令1未执行成功，那么就执行命令2。&lt;br /&gt;
3.()和{}&lt;br /&gt;
如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。&lt;br /&gt;
为了在当前shell中执行一组命令，可以用命令分隔符隔开每一个命令，并把所有的命令&lt;br /&gt;
用圆括号()括起来。&lt;br /&gt;
它的一般形式为：&lt;br /&gt;
(命令1;命令2;. . .)&lt;br /&gt;
如果使用{}来代替()，那么相应的命令将在子shell而不是当前shell中作为一个整体被执行，只有在{}中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子shell中执行，否则在当前shell执行。它的一般形式为：  &lt;br /&gt;
{命令1;命令2;. . . }  &lt;/p&gt;
</description>
        <pubDate>Sun, 01 Feb 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/02/01/Linux-point6.html</link>
        <guid isPermaLink="true">index.html/blog/2015/02/01/Linux-point6.html</guid>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux学习笔记10-sed</title>
        <description>&lt;h2 id=&quot;linux10-sed&quot;&gt;Linux学习笔记10-sed&lt;/h2&gt;
&lt;p&gt;sed是一个非交互性文本流编辑器。它编辑文件或标准输入导出的文本拷贝。标准输入可能是来自键盘、文件重定向、字符串或变量，或者是一个管道的文本。sed可以做些什么呢,与同是编辑器的vi有何不同？  &lt;/p&gt;

&lt;p&gt;可以在命令行输入sed命令，也可以在一个文件中写入命令，然后调用sed，这与awk基本相同。使用sed需要记住的一个重要事实是，无论命令是什么， sed并不与初始化文件打交道，它操作的只是一个拷贝，然后所有的改动如果没有重定向到一个文件，将输出到屏幕。&lt;br /&gt;
因为sed是一个非交互性编辑器，必须通过行号或正则表达式指定要改变的文本行。&lt;br /&gt;
和grep与awk一样，sed是一种重要的文本过滤工具，或者使用一行命令或者使用管道与grep与awk相结合  &lt;/p&gt;

&lt;p&gt;读取数据&lt;br /&gt;
sed从文件的一个文本行或从标准输入的几种格式中读取数据，将之拷贝到一个编辑缓冲区，然后读命令行或脚本的第一条命令，并使用这些命令查找模式或定位行号编辑它。重复此过程直到命令结束。  &lt;/p&gt;

&lt;p&gt;调用sed&lt;br /&gt;
调用sed有三种方式：&lt;br /&gt;
1.在命令行键入命令；&lt;br /&gt;
	sed [选项] sed命令输入文件。&lt;br /&gt;
	在命令行使用sed命令时，实际命令要加单引号。sed也允许加双引号。&lt;br /&gt;
2.将sed命令插入脚本文件，然后调用sed；&lt;br /&gt;
	sed [选项] -f sed脚本文件输入文件&lt;br /&gt;
3.将sed命令插入脚本文件，并使sed脚本可执行。&lt;br /&gt;
	sed脚本文件[选项] 输入文件&lt;br /&gt;
不管是使用shell命令行方式或脚本文件方式，如果没有指定输入文件， sed从标准输入中接受输入，一般是键盘或重定向结果。&lt;br /&gt;
sed选项如下：&lt;br /&gt;
n 不打印；sed不写编辑行到标准输出，缺省为打印所有行（编辑和未编辑）。p命令可以用来打印编辑行。&lt;br /&gt;
c 下一命令是编辑命令。使用多项编辑时加入此选项。如果只用到一条sed命令，此选项无用，但指定它也没有关系。&lt;br /&gt;
f 如果正在调用sed脚本文件，使用此选项。此选项通知sed一个脚本文件支持所有的sed&lt;br /&gt;
命令，例如：sed -f myscript.sed input_file，这里myscript.sed即为支持sed命令的文件。  &lt;/p&gt;

&lt;p&gt;保存sed输出&lt;br /&gt;
由于不接触初始化文件，如果想要保存改动内容，简单地将所有输出重定向到一个文件即可。下面的例子重定向sed命令的所有输出至文件‘myoutfile’，当对结果很满意时使用这种方法。&lt;br /&gt;
sed ‘some-sed-commands’ input-file &amp;gt; myoutfile  &lt;/p&gt;

&lt;p&gt;使用sed在文件中查询文本&lt;br /&gt;
sed浏览输入文件时，缺省从第一行开始，有两种方式定位文本：&lt;br /&gt;
1) 使用行号，可以是一个简单数字，或是一个行号范围。&lt;br /&gt;
2) 使用正则表达式。&lt;br /&gt;
如：&lt;br /&gt;
x                       x为一行号，如1&lt;br /&gt;
x , y                   表示行号范围从x到y，如2，5表示从第2行到第5行&lt;br /&gt;
/pattern/               查询包含模式的行。例如/disk/或/[a-z]/&lt;br /&gt;
/pattern/pattern/       查询包含两个模式的行。例如/disk/  disks/&lt;br /&gt;
/pattern/, x            在给定行号上查询包含模式的行。如/ribbon/,3&lt;br /&gt;
x,/pattern/             通过行号和模式查询匹配行。3./vdu/&lt;br /&gt;
x,y!                    查询不包含指定行号x和y的行。1 , 2 !  &lt;/p&gt;

&lt;p&gt;基本sed编辑命令
p    打印匹配行
=    显示文件行号
a\   在定位行号后附加新文本信息
i\   在定位行号后插入新文本信息
d    删除定位行
c\   用新文本替换定位文本
s    使用替换模式替换相应模式
r    从另一个文件中读文本
w    写文本到一个文件
q    第一个模式匹配完成后推出或立即推出
l    显示与八进制A S C I I代码等价的控制字符
{}   在定位行执行的命令组
n    从另一个文件中读文本下一行，并附加在下一行
g    将模式2粘贴到/pattern n/
y    传送字符
n    延续到下一输入行；允许跨行的模式匹配语句&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Feb 2015 00:00:00 +0800</pubDate>
        <link>index.html/blog/2015/02/01/Linux-point10.html</link>
        <guid isPermaLink="true">index.html/blog/2015/02/01/Linux-point10.html</guid>
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
