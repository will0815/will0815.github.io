<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="description" content="Will go, Just do it.">
  <meta name="author" content="Will.Quan">
  <meta name="keywords" content="Will go, Just do it., willgo, 最好的从未错过, Will.Quan">
  <title>Will go, Just do it.</title>
  <link rel="canonical" href="index.html">
  <link rel="icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/res/css/public.css">
  <link rel="stylesheet" href="/res/css/light.css">
  <script src="/res/js/light.js"></script>
  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fda48b6233123178f300913a0e707883e' type='text/javascript'%3E%3C/script%3E"));
</script>

</head>
<body>
  <div id="blog">
    <div class="sidebar">
  <div class="profilepic">
    <a href="/"><img src="/res/img/icon.png" alt="logo"></img></a>
  </div>
  <h1 class="title"><a href="/">willgo</a></h1>
  <h2 class="sub-title">最好的从未错过</h2>
  <nav id="nav">
    <ul>
    
      <li><a href="/page/timing.html"><i class="fa fa-clock-o"></i>&nbsp;资料时间</a></li>
    
      <li><a href="/page/category.html"><i class="fa fa-tags"></i>&nbsp;文章分类</a></li>
    
      <li><a href="/page/read.html"><i class="fa fa-book"></i>&nbsp;逗绊读书</a></li>
    
      <li><a href="/page/life.html"><i class="fa fa-eyedropper"></i>&nbsp;生活记录</a></li>
    
      <li><a href="/page/about.html"><i class="fa fa-paper-plane-o"></i>&nbsp;假装关于</a></li>
    
    </ul>
  </nav>  
  <nav id="sub-nav">
    <a class="weibo " href="http://weibo.com/u/2369015654" title="新浪微博" target="_blank"><i class="fa fa-weibo"></i></a>
    <a class="github" href="https://github.com/will0815/" title="GitHub" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    <a class="rss" href="/page/feed.xml" title="RSS订阅" target="_blank"><i class="fa fa-rss"></i></a>
  </nav>
  <div id="license">
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" title="本站所有作品采用：&#10;知识共享《署名 非商业性使用 相同方式共享 3.0》&#10;进行许可" >
    <img alt="License" height="31" width="88" src="/res/img/license.png" /></a>
  </div>
</div>
    <div class="main">
    
<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2014/09/27/AMD--CMD.html">AMD & CMD</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年09月27日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#不懂">不懂</a>
      </p>
    </header>
    <div class="post-main">
      <p>http://blog.csdn.net/dojotoolkit/article/details/7820321</p>

<p><strong>AMD</strong></p>

<p>随着web应用不断发展和对JavaScript依赖的进一步加深，
出现了使用模块（Modules）来组织代码和依赖性。模块使得我们创建明确清晰的组件和接口，
这些组件和接口能够很容易的加载并连接到其依赖组件。 AMD模块系统提供了使用JavaScript模块来构建Web应用的完美方式，
并且这种方式具有形式简单，异步加载和广泛采用的特点。</p>

<p>异步模块定义（AMD）格式是一套API，它用于定义可重用的并能在多种框架使用的模块。
开发AMD是为了提供一种定义模块的方式，这种方式可以使用原生的浏览器脚本元素机制来实现模块的异步加载。
AMD API由2009年Dojo 社区的讨论中产生，然后移动到讨论CommonJS如何更好的为浏览器适应CommonJS模块格式（被NodeJS使用）。
CommonJS已经发展成为单独的一个标准并有其专门的社区。AMD已经广泛普及，形成了众多模块加载实现并被广泛使用。在SitePen公司，
我们广泛的使用Dojo的AMD机制工作，为其提供支持，并积极的建设这一机制。</p>

<p>CMD Common Module Definition</p>

<p>在CMD规范里面，一个模块就是一个Javascript文件</p>

<pre><code>define(factory); define是全局函数，来定义模块 仅接收一个factory参数，可以是函数，对象，字符串等类型
</code></pre>

<ol>
  <li>
    <p>factory为对象、字符串等非函数类型时候，表示模块的接口是该对象、字符串等值
Js代码</p>

    <pre><code> define({
 "foo":"bar"
 }); 通过字符串定义模版模块 Js代码

 define('I am a template.My name is .');
</code></pre>
  </li>
  <li>
    <p>factory为函数时候，表示模块的构造方法。
执行该方法，可以得到模块向外提供的接口。默认3个参数：require 、 exports 、 module
Js代码</p>

    <pre><code> define(function(require,exports,module){
 //...
 });
 require --------- 是一个方法，用来获取其他模块提供的接口。 Js代码
</code></pre>

    <p>define(function(require){
 var a = require(‘./a’);
 a.doSomething;
 });
require接受模块标识作为唯一参数，模块标识书写需要遵循一些规范。</p>

    <p>require.async
———- 可以用来异步加载模块，并在加载完成后执行指定的回调。
Js代码</p>

    <pre><code> define(function(require,exports,module){
 //异步加载b
 require.async('./b',function(b){
 b.doSomething;
 });
 //异步加载多个模块
 require.async(['./c','./d'],function(c,d){
 //
 ........
 })
 });
 require.resolve --------- 使用模块系统内部的路径解析机制来返回模块的路径。该函数不会加载模块，只返回解析后的绝对路径。 Js代码
</code></pre>

    <p>define(function(require,exports){
 console.log(require.resolve(‘./b’));
 //../b.js
 });
 require.cache
———- 可以查看模块系统加载过的所有模块。
某些情况下，需要重新加载某个模块，可以得到该模块的url，然后通过delete require.cache[url] 来将其信息删除。
exports
——– 是一个对象，用来向外提供模块接口。
Js代码</p>

    <pre><code> define(function(require,exports){
 exports.foo = "bar";
 exports.doSomething = function(){
 ...............
 }
 }); 除了给exports对象增加成员，还可以以return的方式直接向外提供接口。 Js代码

 define(function(require,exports,module){
 return {
 fool: "bar",
 doSomething:function(){
 .............
 }
 };
 }); 当然如果只是返回一个对象，可以直接： Js代码

 define({
 foo: "bar",
 doSomething:function(){}
 });
</code></pre>
  </li>
</ol>

<p>注释：在factory里面给exports重新赋值是没有意义的，因为exports仅仅是module.exports的一个引用，直接给exports重新赋值并不会修改module.exports的值。
错误的例子：</p>

<p>Js代码</p>

<pre><code>	define(function(require,exports,module){
	exports = {
	foo: "bar",
	doSomething:function(){}
	}
	}); 正确的应该是：
</code></pre>

<p>Js代码</p>

<pre><code>	define(function(require,exports,module){
	module.exports = {
	foo: "bar",
	doSomething:function(){}
	}
	}); module module 是一个对象，存储了与当前模块关联的一些属性和方法。 module.id ---------- 模块标识 Js代码

	define(function(require,exports,module){
	console.log(require(module.id) === exports); // true
	});
	module.uri
	------------ 根据模块系统的路径解析规则得到的模块绝对路径
	module.dependencies
	------------ 是一个数组，标识当前模块的依赖列表
	module.parent
	------------ 指向初始化调用当前模块的模块。可以得到模块初始化的callstack
	module.factory
	------------ 指向define(factory)中的factory参数
	module.status
	------------ 当前模块的状态，是一个数值
	module.exports ------------ 当前模块对外提供的接口 传给factory构造方法的exports参数是module.exports对象的一个引用。 比如当模块的接口是某一个类的实例时候，需要通过module.exports来实现 Js代码

	define(function(require,exports,module){
	console.log(module.exports === exports); // true
	module.exports = new SomeClass();
	console.log(module.exports === exports); //false
	});
	module.require 在module环境中运行require，一般用于插件开发
</code></pre>

      <div class="readall"><a href="/blog/2014/09/27/AMD--CMD.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2014/06/08/HBasesession.html">HBase第一次session记录</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年06月08日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#hadoop">hadoop</a>
      </p>
    </header>
    <div class="post-main">
      <ol>
  <li>数据本地化(Data Localization)
数据存在当前JVM 或是当前磁盘</li>
  <li>HBase的架构 实现数据与操作的分离，没有本地数据。
其数据存放于hadoop上，所以集群能具有很强的健壮性：
hase写过程：先写Hlog</li>
  <li>HBase的没有指定master，在哪台机器上启动HBase集群，该台机就是master。</li>
  <li>rowkey是数据的一部分，其必须人工指定。
column family 在定义表时需指明。</li>
  <li>HBase没有database的概念。</li>
  <li>
    <p>HBase表结构：</p>

    <pre><code> table
 |-column family
 |-column
 |-cell
 |-timestamp
 |-value
</code></pre>
  </li>
  <li>HBase最佳实践：column family 不应超过两个，因为一个column family 对应一个store，flush和compaction的触发的基本单位都是Region级别，所以当一个column family有大量的数据的时候会触发整个region里面的其他column family的memstore（其实这些memstore可能仅有少量的数据，还不需要flush的）也发生flush动作；另外compaction触发的条件是当store file的个数（不是总的store file的大小）达到一定数量的时候会发生，而flush产生的大量store file通常会导致compaction，flush/compaction会发生很多IO相关的负载，这对Hbase的整体性能有很大影响。</li>
  <li>一个table对应一个或多个region，在map/reduce 中对应一个map
一个column family 对应一个store。 store 中含一个menstore 和多个fileStore
当menstore 存储到达一定阀值就生成一个filestore， fileStore存放在hdfs上，
当fileStore 数量到达一定阀值就将其合并成一个大的file。</li>
  <li>qualifier对应column</li>
  <li>在插入rowkey时，不考虑region的大小及状态，只是根据它的access 编码排序，找到对应的startkey，endkey,确定插入的位置。</li>
  <li>HBase两张管理表：+
.META.:管理用户region，它可以有多个region。
ROOT: 管理.META.的region，它只有一个region。
所以读写数据的流程为：
client–&gt;ROOT–&gt;META–&gt;regionserver
在数据的读写过程中client不会与master产生关系
master只是负责管理表结构。</li>
  <li>利用backup-master机制，解决master单点的问题。</li>
  <li>region在存储的数据到达一定阀值后将split，split的同时更形.META.和ROOT表的相关数据。
split region的过程不需要master的参与，master只负责将split后新的region分配到对应的regionserver。</li>
  <li>HBase的数据安全机制之一：在插入数据时先写Hlog然后在写到内存。
一个regionserver中只有一个Hlog， Hlog中只记录内存中存放的数据。
当机器挂掉后，master会根据Hlog中region将其分割，然后分配到不同的机器加载，做数据恢复。</li>
</ol>

      <div class="readall"><a href="/blog/2014/06/08/HBasesession.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2014/05/21/HashMap-equalshashCode.html">HashMap equals&hashCode</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2014年05月21日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#java">java</a>
      </p>
    </header>
    <div class="post-main">
      <p>HashMap源码中获取value的实现方法如下：</p>

<pre><code>public V get(Object key) {
if (key == null)
return getForNullKey();
int hash = hash(key.hashCode());
for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
e != null;
e = e.next) {
Object k;
if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
return e.value;
}
return null;
}
</code></pre>

<p>遍历HashMap的内部维护的Entry数组，找到匹配的目标Entry并返回其value即可。 匹配的标准是：
Entry的hash值是否与参数key的hash值相等。 (这要求我们必须正确实现作为key的对象的hashCode()方法)
Entry的key是否与参数key为同一对象，或者Entry的key”等于”参数key。 (注意是否”等于”， 是通过调用参数key的equals()方法来完成的， 这要求我们必须正确实现作为key的对象的equals()方法)</p>

<p>So, 我们在自定义map的key的时候，需要实现equals和hashCode两个方法，hashCode可偷懒直接返回一个数字。。。</p>

<p>关于HashCode的官方文档定义：
hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。</p>

<p>hashCode 的常规协定是：</p>

<p>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p>

<p>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。
以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。</p>

<p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）
当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>

<p>综上：</p>

<ol>
  <li>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；</li>
  <li>如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；</li>
  <li>如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；</li>
  <li>两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。</li>
</ol>

<p>hashCode用于查找使用的，equals是用于比较两个对象的是否相等的。</p>

<ol>
  <li>
    <p>hashcode是用来查找的，
例如内存中有这样的位置
0 1 2 3 4 5 6 7
一个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。
但如果用hashcode那就会使效率提高很多。
我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p>
  </li>
  <li>
    <p>但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。
也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。
那么。重写了equals()，为什么还要重写hashCode()呢？
在一个桶里找东西，先要找到这个桶，通过重写hashcode()来找到桶，equals()比较</p>
  </li>
</ol>

      <div class="readall"><a href="/blog/2014/05/21/HashMap-equalshashCode.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="pagination">
  
  
  <a class="pagination-item newer" href="/page/7"><i class="fa fa-arrow-left"></i>&nbsp;&nbsp;上一页</a>
  
    
  
  <span class="pagination-item older">下一页&nbsp;&nbsp;<i class="fa fa-arrow-right"></i></span>
  
</div>
    <footer>Copyright&nbsp;&copy;&nbsp;2014 <a href="index.html">willgo</a><br/><i class="fa fa-cogs" style="color:blueviolet;">&nbsp;</i>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a></footer>
    </div>
  </div>    
  <div id="top"><a id="rocket" href="javascript:;" title="返回顶部"><i></i></a></div>
  
</body>
</html>