<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <meta name="description" content="Will go, Just do it.">
  <meta name="author" content="Will.Quan">
  <meta name="keywords" content="Will go, Just do it., willgo, 最好的从未错过, Will.Quan">
  <title>Will go, Just do it.</title>
  <link rel="canonical" href="index.html">
  <link rel="icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/res/img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/res/css/public.css">
  <link rel="stylesheet" href="/res/css/light.css">
  <script src="/res/js/light.js"></script>
  <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fda48b6233123178f300913a0e707883e' type='text/javascript'%3E%3C/script%3E"));
</script>

</head>
<body>
  <div id="blog">
    <div class="sidebar">
  <div class="profilepic">
    <a href="/"><img src="/res/img/icon.png" alt="logo"></img></a>
  </div>
  <h1 class="title"><a href="/">willgo</a></h1>
  <h2 class="sub-title">最好的从未错过</h2>
  <nav id="nav">
    <ul>
    
      <li><a href="/page/timing.html"><i class="fa fa-clock-o"></i>&nbsp;资料时间</a></li>
    
      <li><a href="/page/category.html"><i class="fa fa-tags"></i>&nbsp;文章分类</a></li>
    
      <li><a href="/page/read.html"><i class="fa fa-book"></i>&nbsp;逗绊读书</a></li>
    
      <li><a href="/page/life.html"><i class="fa fa-eyedropper"></i>&nbsp;生活记录</a></li>
    
      <li><a href="/page/about.html"><i class="fa fa-paper-plane-o"></i>&nbsp;假装关于</a></li>
    
    </ul>
  </nav>  
  <nav id="sub-nav">
    <a class="weibo " href="http://weibo.com/u/2369015654" title="新浪微博" target="_blank"><i class="fa fa-weibo"></i></a>
    <a class="github" href="https://github.com/will0815/" title="GitHub" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    <a class="rss" href="/page/feed.xml" title="RSS订阅" target="_blank"><i class="fa fa-rss"></i></a>
  </nav>
  <div id="license">
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" title="本站所有作品采用：&#10;知识共享《署名 非商业性使用 相同方式共享 3.0》&#10;进行许可" >
    <img alt="License" height="31" width="88" src="/res/img/license.png" /></a>
  </div>
</div>

    <div class="main">
        <div style="font-family: segoepr;font-size: 40px;
              margin-top:-5px; color:#fff;">
            <script type="text/javascript" 
            src="http://open.iciba.com/ds_open.php?id=11519&name=willgo&auth=BE45CDE6481CC46336529A1B407855B1" charset="utf-8">
            </script>
        </div>
    
<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point9.html">Linux学习笔记9-AWK</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux9-awk">Linux学习笔记9-AWK</h2>
<p>AWK是所有shell过滤工具中最难掌握的，不知道为什么，也许是其复杂的语法或含义不明确的错误提示信息。在学习awk语言过程中，就会慢慢掌握诸如Bailing out 和awk:cmd.Line:等错误信息。可以说awk是一种自解释的编程语言，之所以要在shell中使用awk是因为awk本身是学习的好例子，但结合awk与其他工具诸如grep和sed，将会使shell编程更加
容易。<br />
调用：<br />
有三种方式调用awk，第一种是命令行方式，如：<br />
awk [-F field-separator] ‘awk命令’ input-file(s)<br />
[-F域分隔符]是可选的，因为awk使用空格作为缺省的域分隔符，因此如果
要浏览域间有空格的文本，不必指定这个选项，但如果要浏览诸如passwd文件，此文件各域以冒号作为分隔符，则必须指明- F选项<br />
awk -F:’awk命令’ input-file<br />
第二种方法是将所有awk命令插入一个文件，并使awk程序可执行，然后用awk命令解释器作为脚本的首行，以便通过键入脚本名称来调用它<br />
awk -f awk-script-file input-files<br />
第三种方式是将所有的awk命令插入一个单独文件. -f选项指明在文件awk_scriptfile中的awk脚本，inputfile(s)是使用awk进行浏览的文件
名。  </p>

<p>awk脚本<br />
在命令中调用awk时，awk脚本由各种操作和模式组成。<br />
如果设置了-F选项，则awk每次读一条记录或一行，并使用指定的分隔符分隔指定域，但如果未设置-F选项，awk假定空格为域分隔符，并保持这个设置直到发现一新行。当新行出现时，awk命令获悉已读完整条记录，然后在下一个记录启动读命令，这个读进程将持续到文件尾或文件不再存在。</p>


      <div class="readall"><a href="/blog/2015/02/01/Linux-point9.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point8.html">Linux学习笔记8-grep 家族</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux8-grep-">Linux学习笔记8-grep 家族</h2>
<p>grep（全局正则表达式版本）允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行。grep支持基本正则表达式，也支持其扩展集   <br />
grep一般格式为：<br />
grep [选项]基本正则表达式[文件]<br />
这里基本正则表达式可为字符串。  </p>

<p>在grep命令中输入字符串参数时，最好将其用双引号括起来。例如：“mystring”。这样做有两个原因，
一是以防被误解为shell命令，<br />
二是可以用来查找多个单词组成的字符串，例如：  <br />
“jet plane”，如果不用双引号将其括起来，那么单词plane将被误认为是一个文件，查询结果将返回“文件不存在”的错误信息。<br />
在调用变量时，也应该使用双引号，诸如： grep “MYVAR”文件名，如果不这样，将没有返回结果。<br />
在调用模式匹配时，应使用单引号。  </p>

<p>常用的grep选项有：<br />
-c 只输出匹配行的计数。<br />
-i 不区分大小写（只适用于单字符）。<br />
-h 查询多文件时不显示文件名。<br />
-l 查询多文件时只输出包含匹配字符的文件名。<br />
-n 显示匹配行及行号。<br />
-s 不显示不存在或无匹配文本的错误信息。<br />
-v 显示不包含匹配文本的所有行。  </p>

<p>grep “will”*.doc 在当前目录下所有.doc文件中查找”will”字符串。  </p>

<p>精确匹配：<br />
grep “will<tab>"*.doc 在当前目录下所有.doc文件精确匹配"will"   还可以写为：grep "will\&gt;"*.doc  
大小写敏感：  
缺省情况下， grep是大小写敏感的，如要查询大小写不敏感字符串，必须使用- i开关。  </tab></p>


      <div class="readall"><a href="/blog/2015/02/01/Linux-point8.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point7.html">Linux学习笔记7-正则表达式介绍</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux7-">Linux学习笔记7-正则表达式介绍</h2>
<p>当从一个文件或命令输出中抽取或过滤文本时，可以使用正则表达式(RE)，正则表达式是一些特殊或不很特殊的字符串模式的集合。<br />
为了抽取或获得信息，我们给出抽取操作应遵守的一些规则。这些规则由一些特殊字符或进行模式匹配操作时使用的元字符组成。也可以使用规则字符作为模式中的一部分进行搜寻。<br />
例如，A将查询A，x将查找字母x  <br />
基本元字符<br />
^ 只只匹配行首<br />
$ 只只匹配行尾<br />
* 只一个单字符后紧跟*，匹配0个或多个此单字符<br />
[ ] 只匹配[ ]内字符。可以是一个单字符，也可以是字符序列。可以使用-表示[ ]内字符序列范围，如用[1-5]代替[12345]<br />
\ 只用来屏蔽一个元字符的特殊含义。因为有时在shell中一些元字符有
特殊含义。\可以使其失去应有意义<br />
. 只匹配任意单字符<br />
pattern{n} 只用来匹配前面pattern出现次数。n为次数<br />
pattern{n,} m 只含义同上，但次数最少为n<br />
pattern{n,m} 只含义同上，但pattern出现次数在n与m之间  </p>

<p>1.使用句点匹配单字符<br />
句点”.”可以匹配任意单字符。例如，如果要匹配一个字符串，以beg开头，中间夹一个任意字符，那么可以表示为beg.n，”.”可以匹配字符串头，也可以是中间任意字符。<br />
在ls -l命令中，可以匹配一定权限：<br />
…x..x ..x  : 匹配用户本身，用户组及其他组成员的执行权限。<br />
“.”允许匹配ASCII集中任意字符，或为字母，或为数字。<br />
2.在行首以^匹配字符串或字符序列<br />
^只允许在一行的开始匹配字符或单词。例如，使用ls -l命令，并匹配目录。之所以可以这样做是因为ls -l命令结果每行第一个字符是d，即代表一个目录。  <br />
^…4XC….  <br />
以上模式表示，在每行开始，匹配任意3个字符，后跟4XC，最后为任意4个字符。^在正则表达式中使用频繁，因为大量的抽取操作通常在行首.<br />
3.在行尾以$匹配字符串或字符  <br />
$与^正相反，它在行尾匹配字符串或字符， $符号放在匹配单词后。假定要匹配以单词test结尾的所有行，操作为：<br />
test$<br />
^$<br />
具体分析为匹配行首，又匹配行尾，中间没有任何模式，因此为空行。<br />
如果只返回包含一个字符的行，操作如下：<br />
^.$<br />
4.使用<em>匹配字符串中的单字符或其重复序列  <br />
使用此特殊字符匹配任意字符或字符串的重复多次表达式。例如：<br />
compu</em>t<br />
将匹配字符u一次或多次：<br />
compuut 
compuuut<br />
compuuuuut<br />
5.使用\屏蔽一个特殊字符的含义  <br />
有时需要查找一些字符或字符串，而它们包含了系统指定为特殊字符的一个字符。什么是特殊字符？一般意义上讲，下列字符可以认为是特殊字符：<br />
$ . ‘ “ * || ^ [] 0 \ + ?<br />
假定要匹配包含字符“ .”的各行而“，”代表匹配任意单字符的特殊字符，因此需要屏蔽其含义。操作如下：<br />
.
6.使用[]匹配一个范围或集合  <br />
使用[ ]匹配特定字符串或字符串集，可以用逗号将括弧内要匹配的不同字符串分开，但并不强制要求这样做（一些系统提倡在复杂的表达式中使用逗号），这样做可以增加模式的可读性。<br />
使用”-“表示一个字符串范围，表明字符串范围从”-“左边字符开始，到”-“右边字符结束。<br />
如果熟知一个字符串匹配操作，应经常使用[]模式。<br />
假定要匹配任意一个数字，可以使用：<br />
[0123456789]<br />
然而，通过使用“-”符号可以简化操作：<br />
[0-9]<br />
7.使用{}匹配模式结果出现的次数<br />
使用*可匹配所有匹配结果任意次，但如果只要指定次数，就应使用\ { \ }，此模式有三种形式，即：<br />
pattern{n} 匹配模式出现n次。<br />
pattern{n,} 匹配模式出现最少n次。<br />
pattern{n,m} 匹配模式出现n到m次之间，n , m为0 -255中任意整数。
请看第一个例子，匹配字母A出现两次，并以B结尾，操作如下：<br />
A{2}B<br />
匹配值为AAB<br />
匹配A至少4次，使用：<br />
A{4,} B<br />
可以得结果AAAAB或AAAAAAAB，但不能为AAAB。  </p>

      <div class="readall"><a href="/blog/2015/02/01/Linux-point7.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point6.html">Linux学习笔记6-命令执行顺序</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux6-">Linux学习笔记6-命令执行顺序</h2>
<p>场景：执行某个命令的时候，有时需要依赖于前一个命令是否执行成功。例如，假设你希望<br />
将一个目录中的文件全部拷贝到另外一个目录中后，然后删除源目录中的全部文件。在删除之前，你希望能够确信拷贝成功，否则就有可能丢失所有的文件。  <br />
1.&amp;&amp;<br />
&amp;&amp;的一般形式：<br />
命令1 &amp;&amp; 命令2<br />
以上表示：命令1返回真(返回0，成功执行)后，命令2才能被执行<br />
如：mv /apps/bin /apps/dev/bin &amp;&amp; rm -r /apps/bin<br />
2.||  <br />
||一般形式：<br />
命令1||命令2<br />
以上表示：命令1未执行成功，那么就执行命令2。<br />
3.()和{}<br />
如果希望把几个命令合在一起执行，shell提供了两种方法。既可以在当前shell也可以在子shell中执行一组命令。<br />
为了在当前shell中执行一组命令，可以用命令分隔符隔开每一个命令，并把所有的命令<br />
用圆括号()括起来。<br />
它的一般形式为：<br />
(命令1;命令2;. . .)<br />
如果使用{}来代替()，那么相应的命令将在子shell而不是当前shell中作为一个整体被执行，只有在{}中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子shell中执行，否则在当前shell执行。它的一般形式为：  <br />
{命令1;命令2;. . . }  </p>

      <div class="readall"><a href="/blog/2015/02/01/Linux-point6.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Linux-point10.html">Linux学习笔记10-sed</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#linux">linux</a>
      </p>
    </header>
    <div class="post-main">
      <h2 id="linux10-sed">Linux学习笔记10-sed</h2>
<p>sed是一个非交互性文本流编辑器。它编辑文件或标准输入导出的文本拷贝。标准输入可能是来自键盘、文件重定向、字符串或变量，或者是一个管道的文本。sed可以做些什么呢,与同是编辑器的vi有何不同？  </p>

<p>可以在命令行输入sed命令，也可以在一个文件中写入命令，然后调用sed，这与awk基本相同。使用sed需要记住的一个重要事实是，无论命令是什么， sed并不与初始化文件打交道，它操作的只是一个拷贝，然后所有的改动如果没有重定向到一个文件，将输出到屏幕。<br />
因为sed是一个非交互性编辑器，必须通过行号或正则表达式指定要改变的文本行。<br />
和grep与awk一样，sed是一种重要的文本过滤工具，或者使用一行命令或者使用管道与grep与awk相结合  </p>

<p>读取数据<br />
sed从文件的一个文本行或从标准输入的几种格式中读取数据，将之拷贝到一个编辑缓冲区，然后读命令行或脚本的第一条命令，并使用这些命令查找模式或定位行号编辑它。重复此过程直到命令结束。  </p>

<p>调用sed<br />
调用sed有三种方式：<br />
1.在命令行键入命令；<br />
	sed [选项] sed命令输入文件。<br />
	在命令行使用sed命令时，实际命令要加单引号。sed也允许加双引号。<br />
2.将sed命令插入脚本文件，然后调用sed；<br />
	sed [选项] -f sed脚本文件输入文件<br />
3.将sed命令插入脚本文件，并使sed脚本可执行。<br />
	sed脚本文件[选项] 输入文件<br />
不管是使用shell命令行方式或脚本文件方式，如果没有指定输入文件， sed从标准输入中接受输入，一般是键盘或重定向结果。<br />
sed选项如下：<br />
n 不打印；sed不写编辑行到标准输出，缺省为打印所有行（编辑和未编辑）。p命令可以用来打印编辑行。<br />
c 下一命令是编辑命令。使用多项编辑时加入此选项。如果只用到一条sed命令，此选项无用，但指定它也没有关系。<br />
f 如果正在调用sed脚本文件，使用此选项。此选项通知sed一个脚本文件支持所有的sed<br />
命令，例如：sed -f myscript.sed input_file，这里myscript.sed即为支持sed命令的文件。  </p>

<p>保存sed输出<br />
由于不接触初始化文件，如果想要保存改动内容，简单地将所有输出重定向到一个文件即可。下面的例子重定向sed命令的所有输出至文件‘myoutfile’，当对结果很满意时使用这种方法。<br />
sed ‘some-sed-commands’ input-file &gt; myoutfile  </p>

<p>使用sed在文件中查询文本<br />
sed浏览输入文件时，缺省从第一行开始，有两种方式定位文本：<br />
1) 使用行号，可以是一个简单数字，或是一个行号范围。<br />
2) 使用正则表达式。<br />
如：<br />
x                       x为一行号，如1<br />
x , y                   表示行号范围从x到y，如2，5表示从第2行到第5行<br />
/pattern/               查询包含模式的行。例如/disk/或/[a-z]/<br />
/pattern/pattern/       查询包含两个模式的行。例如/disk/  disks/<br />
/pattern/, x            在给定行号上查询包含模式的行。如/ribbon/,3<br />
x,/pattern/             通过行号和模式查询匹配行。3./vdu/<br />
x,y!                    查询不包含指定行号x和y的行。1 , 2 !  </p>

<p>基本sed编辑命令
p    打印匹配行
=    显示文件行号
a\   在定位行号后附加新文本信息
i\   在定位行号后插入新文本信息
d    删除定位行
c\   用新文本替换定位文本
s    使用替换模式替换相应模式
r    从另一个文件中读文本
w    写文本到一个文件
q    第一个模式匹配完成后推出或立即推出
l    显示与八进制A S C I I代码等价的控制字符
{}   在定位行执行的命令组
n    从另一个文件中读文本下一行，并附加在下一行
g    将模式2粘贴到/pattern n/
y    传送字符
n    延续到下一输入行；允许跨行的模式匹配语句</p>

      <div class="readall"><a href="/blog/2015/02/01/Linux-point10.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="posts">
  <section class="post">
    <header class="post-header">
      <h1 class="post-title"><a href="/blog/2015/02/01/Hive-structure.html">Hive基础架构</a></h1>
      <p class="post-meta">
        <i class="fa fa-calendar"></i>
        2015年02月01日
        <i class="space"></i>
        <i class="fa fa-tags"></i>
        <a class="post-category" href="/page/category.html#hadoop">hadoop</a>
      </p>
    </header>
    <div class="post-main">
      <p>Hive基础架构<br />
Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析,Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。 <br />
Hive技术架构图：<br />
<img src="/image/hive1.png" alt="" /><br />
服务端组件： <br />
Driver组件：该组件包括Complier、Optimizer和Executor，它的作用是将HiveQL（类SQL）语句进行解析、编译优化，生成执行计划，然后调用底层的mapreduce计算框架。 <br />
Metastore组件：元数据服务组件，这个组件存储hive的元数据，hive的元数据存储在关系数据库里，hive支持的关系数据库有derby、mysql。元数据对于hive十分重要，因此hive支持把metastore服务独立出来，安装到远程的服务器集群里，从而解耦hive服务和metastore服务，保证hive运行的健壮性。<br />
Thrift服务：thrift是facebook开发的一个软件框架，它用来进行可扩展且跨语言的服务的开发，hive集成了该服务，能让不同的编程语言调用hive的接口。 <br />
客户端组件： <br />
CLI：command line interface，命令行接口。 <br />
Thrift客户端：上面的架构图里没有写上Thrift客户端，但是hive架构的许多客户端接口是建立在thrift客户端之上，包括JDBC和ODBC接口。 <br />
WEBGUI：hive客户端提供了一种通过网页的方式访问hive所提供的服务。这个接口对应hive的hwi组件（hive web interface），使用前要启动hwi服务。 <br />
一个Hive hsql 执行流程<br />
<img src="/image/hive2.png" alt="" />  </p>

      <div class="readall"><a href="/blog/2015/02/01/Hive-structure.html" id="post-readall">阅读全文&nbsp;<i class="fa fa-chevron-right"></i></a></div>
    </div>
  </section>
</div>

<div class="pagination">
  
  
  <a class="pagination-item newer" href="/page/3"><i class="fa fa-arrow-left"></i>&nbsp;&nbsp;上一页</a>
  
    
  
  <a class="pagination-item older" href="/page/5">下一页&nbsp;&nbsp;<i class="fa fa-arrow-right"></i></a>
  
</div>
    <footer>Copyright&nbsp;&copy;&nbsp;2015 <a href="index.html">willgo</a><br/><i class="fa fa-cogs" style="color:blueviolet;">&nbsp;</i>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>
</br> <a href="http://m.kuaidi100.com" target="_blank">快递查询</a> 
</footer>

    </div>
  </div>    
  <div id="top"><a id="rocket" href="javascript:;" title="返回顶部"><i></i></a></div>
  
</body>
</html>
